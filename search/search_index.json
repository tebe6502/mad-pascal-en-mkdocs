{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Mad-Pascal Mad-Pascal (MP) is a 32-bit Turbo Pascal compiler for Atari 8-Bit and other MOS 6502 CPU -based computers. By design, it is compatible with the Free Pascal Compiler (FPC) (the -MDelphi switch should be active). This means the possibility of obtaining executable code for Atari 8-bit , Windows and every other platform for which FPC exists. Mad-Pascal is not a port of FPC . It has been written based on of SUB-Pascal (2009), XD-Pascal (2010), the author of which is Vasiliy Tereshkov . Sources are on GitHub with release for Windows operating system. History 1.7.0 [STRIPED] for arrays with a maximum range of 0..255 new target, neo6502 (-t neo) GRAPH.INC: Circle (faster version) fixes lib/aplib.pas fixes lib/zx0.pas improved CASE optimization added directive {$UNITPATH filename} as equivalent to {$LIBRARYPATH filename} added ability to specify a path for a module declared by USES, e.g: uses crt, vector in '...\\3d_vector.pas'; added support for LIBRARY modules added EXTERNAL modifier for variables, procedures, functions added ability to set compilation address from program level, e.g.: program name : address; library name : address; 1.6.9 improved memory allocation for arrays [0..0], 'ABSOLUTE $0000' is enforced initially, save 1 byte of memory added possibility to declare arrays without specifying their size, e.g.: var tab: array of byte = [1,3,4,3,1]; var tb: array of char = 'abcdefghij'; new compiler directive {$bin2csv filename} allows to initialize arrays e.g.: var tb: array of byte = [ {$bin2csv filename} ]; new compiler directive {$optimization loopunroll} , {$optimization noloopunroll} , performs FOR loop unrolling with fixed parameters new BLOWFISH module allowing to encrypt, decrypt character strings according to specified key new example a8\\AES-Rijndeal 1.6.7-1.6.8 Resignation of type expansion for expressions with SHR new SAPR resource type, SAPRPLAY for RMTPLAY, you can specify the address for variables on the null page as the second parameter SizeOfResource(variable, name) unit SAPLZSS unit SHANTI unit SHA1 unit xSFX unit SYSTEM: NtoBE, RorByte, RorWord, RorDWord, RolByte, RolWord, RolDWord, SarShortint, SarSmallint, SarLongint possibility to instantiate an array of CHAR type by STRING (if string is shorter spaces will be inserted), e.g.: tab: array [0..15] of char = '0123456789ABCDEF'; fixed passing function values through arrays added support for VBLKI interrupts (immediate) via SetIntVec, GetIntVec (https://mads.atari8.info/doc/pl/przerwania/) rewritten compiler code for mod separable modules rewritten code for handling arrays with pointers to records tab: array [0..x] of record^ added optimization 'Common head/tail Sequence coalescing' 1.6.6 improved implementation of EXIT added ability to generate code for RAW (-target) added support for the INLINE modifier for procedures and functions added ability to declare a variable on the null page by using the REGISTER modifier added support for TEXTFILE (TEXT) type unit INIFILES unit ZX2 unit SYSUTILS: CompareMem, TryStrToInt unit SYSTEM: CompareByte, Pos, Delete improved passing of parameters to objects (OBJECT) without participation of the :STACKORIGIN program stack (in most cases) added possibility to mark a variable as transient [volatile]. for OBJECT added methods CONSTRUCTOR, DESTRUCTOR added support for macros {$define label (parameters) := expression} added 'FOR element IN array' construction for arrays not exceeding 256 bytes more free memory on zero page, FXPTR, PSPTR pointers are now allocated depending on whether they are used added support for FLOAT16 type added support for procedural type 1.6.5 rewritten handling of CASE OF rewritten code optimization for arrays not exceeding 256 bytes optimization for conditions '>', '<=' added memory allocation for STRING-type arrays (so far only the pointer was put away, it worked like 'array of ^string') new platform added, Commodore C4 Plus unit GRAPHICS: procedure Font(charset: pointer); unit STRINGUTILS unit MISC, RMT, CMC, MPT: DetectAntic unit SYSTEM revised to include ATARI, C64, C4Plus platforms unit ZX0 unit HCM2 added support of $resource (RCDATA, RCASM) for C64, C4Plus platforms, resources are sorted by ascending addresses extended RCDATA resource with possibility to specify ofset for read file added support for Pascal compliant syntax for ASM block, no { } brackets required added new directive {$codealign proc = value}, {$codealign loop = value} allowing to align generated code 1.6.4 multiplying procedures u8x8, u16x16 replaced by code from CC65 adding the POKEY reset code at the beginning of the program launch optimization of conditional IF expressions () and () and ... IF () or () or ... CMP_SHORTINT, CMP_SMALLINT optimization GRAPH, FASTGRAPH: SetActiveBuffer, SetDisplayBuffer, NewDisplayBuffer, SwitchDisplayBuffer, example demoeffects\\lines2.pas, line3.pas, line4.pas GRAPH: Ellipse procedure (X, Y, StAngle, EndAngle, xRadius,yRadius: Word); MATH: Hypot SYSTEM: Length(string_array[element]) SYSTEM: GetMem, FreeMem SYSTEM: IntToStr(CARDINAL), Str(CARDINAL, STRING) SYSUTILS: ByteToStr(BYTE): STRING SYSUTILS: corrected FindFirst, StrToFloat SYSTEM: corrected Val(string, real, code) ; Val(string, single, code) new CIO unit: Opn, Cls, Get, Put, BGet, BPut, XIO new SIODISK unit, separated from the SYSTEM new S2 unit, integrated with handler installer VBXE-S2: (S_VBXE.SYS) new DEFLATE unit, which performs DEFLATE decompression (procedure unDEF), example compression\\undef.pas new LZ4 unit, implementing LZ4 decompression (procedure unLZ4), example compression\\unlz4.pas, unlz4_stream.pas new APLIB unit, which performs apLib decompression (procedure unApl), example compression\\unapl.pas, unapl_stream.pas new CRC unit: function crc32(crc: cardinal; buf: Pbyte; len: word) a new PASCAL procedure/function modifier, causing a new memory block to be assigned/released for variables each time a procedure/function is called, example 'math\\evaluate.pas'. added ability to disable ROM while maintaining system operation, {$DEFINE ROMOFF} shorter names of the switch -zpage (-z), -stack (-s), -data (-d), -code (-c), -define (-d), -ipath (-i) added possibility to generate code for C64 (-t c64) 1.6.3 fixes, optimizations SYSUTILS: Trim SYSTEM: PByte, PByteArray, PWord GRAPH, FASTGRAPH: TFrameBuffer, DisplayBuffer, FrameBuffer, SwitchBuffer, Scanline BLIBS: unit GR10PP LIB: unit GR4PP 1.6.0 - 1.6.2 new EFAST unit for speeding up character output to E device: SYSTEM: function Copy(var S: String; Index: Byte; Count: Byte): String; SYSTEM: Palette, HPalette added support for one-dimensional arrays of type ^RECORD (pointer to a record) optimization of conditional blocks, the shortest, fastest possible resulting code is generated added PChar type, [link]https://www.freepascal.org/docs-html/rtl/system/pchar.html added ability to return function value by enumeration type added new switch -define:symbol added new switch -ipath:includepath 1.5.9 - 1.6.0 SYSTEM: TDateTime GRAPH, FASTGRAPH: Arc, PieSlice, TLastArcCoords, LastArcCoords SYSUTILS: Now, Date, DateToStr, DecodeDate, DecodeDateTime, DecodeTime, EncodeDate, EncodeDateTime, EncodeTime, IsLeapYear, BoolToStr, StrToBool STRUTILS: AddChar, AddCharR, PadLeft, PadRight Added support for {$INCLUDE %DATE%}, {$INCLUDE %TIME%}, [link]https://www.freepascal.org/docs-html/prog/progsu41.html switches -CODE:, -DATE:, -STACK:, -ZPAGE: by default require HEX value without initial '$' character.","title":"Mad-Pascal"},{"location":"#mad-pascal","text":"Mad-Pascal (MP) is a 32-bit Turbo Pascal compiler for Atari 8-Bit and other MOS 6502 CPU -based computers. By design, it is compatible with the Free Pascal Compiler (FPC) (the -MDelphi switch should be active). This means the possibility of obtaining executable code for Atari 8-bit , Windows and every other platform for which FPC exists. Mad-Pascal is not a port of FPC . It has been written based on of SUB-Pascal (2009), XD-Pascal (2010), the author of which is Vasiliy Tereshkov . Sources are on GitHub with release for Windows operating system.","title":"Mad-Pascal"},{"location":"#history","text":"","title":"History"},{"location":"#170","text":"[STRIPED] for arrays with a maximum range of 0..255 new target, neo6502 (-t neo) GRAPH.INC: Circle (faster version) fixes lib/aplib.pas fixes lib/zx0.pas improved CASE optimization added directive {$UNITPATH filename} as equivalent to {$LIBRARYPATH filename} added ability to specify a path for a module declared by USES, e.g: uses crt, vector in '...\\3d_vector.pas'; added support for LIBRARY modules added EXTERNAL modifier for variables, procedures, functions added ability to set compilation address from program level, e.g.: program name : address; library name : address;","title":"1.7.0"},{"location":"#169","text":"improved memory allocation for arrays [0..0], 'ABSOLUTE $0000' is enforced initially, save 1 byte of memory added possibility to declare arrays without specifying their size, e.g.: var tab: array of byte = [1,3,4,3,1]; var tb: array of char = 'abcdefghij'; new compiler directive {$bin2csv filename} allows to initialize arrays e.g.: var tb: array of byte = [ {$bin2csv filename} ]; new compiler directive {$optimization loopunroll} , {$optimization noloopunroll} , performs FOR loop unrolling with fixed parameters new BLOWFISH module allowing to encrypt, decrypt character strings according to specified key new example a8\\AES-Rijndeal","title":"1.6.9"},{"location":"#167-168","text":"Resignation of type expansion for expressions with SHR new SAPR resource type, SAPRPLAY for RMTPLAY, you can specify the address for variables on the null page as the second parameter SizeOfResource(variable, name) unit SAPLZSS unit SHANTI unit SHA1 unit xSFX unit SYSTEM: NtoBE, RorByte, RorWord, RorDWord, RolByte, RolWord, RolDWord, SarShortint, SarSmallint, SarLongint possibility to instantiate an array of CHAR type by STRING (if string is shorter spaces will be inserted), e.g.: tab: array [0..15] of char = '0123456789ABCDEF'; fixed passing function values through arrays added support for VBLKI interrupts (immediate) via SetIntVec, GetIntVec (https://mads.atari8.info/doc/pl/przerwania/) rewritten compiler code for mod separable modules rewritten code for handling arrays with pointers to records tab: array [0..x] of record^ added optimization 'Common head/tail Sequence coalescing'","title":"1.6.7-1.6.8"},{"location":"#166","text":"improved implementation of EXIT added ability to generate code for RAW (-target) added support for the INLINE modifier for procedures and functions added ability to declare a variable on the null page by using the REGISTER modifier added support for TEXTFILE (TEXT) type unit INIFILES unit ZX2 unit SYSUTILS: CompareMem, TryStrToInt unit SYSTEM: CompareByte, Pos, Delete improved passing of parameters to objects (OBJECT) without participation of the :STACKORIGIN program stack (in most cases) added possibility to mark a variable as transient [volatile]. for OBJECT added methods CONSTRUCTOR, DESTRUCTOR added support for macros {$define label (parameters) := expression} added 'FOR element IN array' construction for arrays not exceeding 256 bytes more free memory on zero page, FXPTR, PSPTR pointers are now allocated depending on whether they are used added support for FLOAT16 type added support for procedural type","title":"1.6.6"},{"location":"#165","text":"rewritten handling of CASE OF rewritten code optimization for arrays not exceeding 256 bytes optimization for conditions '>', '<=' added memory allocation for STRING-type arrays (so far only the pointer was put away, it worked like 'array of ^string') new platform added, Commodore C4 Plus unit GRAPHICS: procedure Font(charset: pointer); unit STRINGUTILS unit MISC, RMT, CMC, MPT: DetectAntic unit SYSTEM revised to include ATARI, C64, C4Plus platforms unit ZX0 unit HCM2 added support of $resource (RCDATA, RCASM) for C64, C4Plus platforms, resources are sorted by ascending addresses extended RCDATA resource with possibility to specify ofset for read file added support for Pascal compliant syntax for ASM block, no { } brackets required added new directive {$codealign proc = value}, {$codealign loop = value} allowing to align generated code","title":"1.6.5"},{"location":"#164","text":"multiplying procedures u8x8, u16x16 replaced by code from CC65 adding the POKEY reset code at the beginning of the program launch optimization of conditional IF expressions () and () and ... IF () or () or ... CMP_SHORTINT, CMP_SMALLINT optimization GRAPH, FASTGRAPH: SetActiveBuffer, SetDisplayBuffer, NewDisplayBuffer, SwitchDisplayBuffer, example demoeffects\\lines2.pas, line3.pas, line4.pas GRAPH: Ellipse procedure (X, Y, StAngle, EndAngle, xRadius,yRadius: Word); MATH: Hypot SYSTEM: Length(string_array[element]) SYSTEM: GetMem, FreeMem SYSTEM: IntToStr(CARDINAL), Str(CARDINAL, STRING) SYSUTILS: ByteToStr(BYTE): STRING SYSUTILS: corrected FindFirst, StrToFloat SYSTEM: corrected Val(string, real, code) ; Val(string, single, code) new CIO unit: Opn, Cls, Get, Put, BGet, BPut, XIO new SIODISK unit, separated from the SYSTEM new S2 unit, integrated with handler installer VBXE-S2: (S_VBXE.SYS) new DEFLATE unit, which performs DEFLATE decompression (procedure unDEF), example compression\\undef.pas new LZ4 unit, implementing LZ4 decompression (procedure unLZ4), example compression\\unlz4.pas, unlz4_stream.pas new APLIB unit, which performs apLib decompression (procedure unApl), example compression\\unapl.pas, unapl_stream.pas new CRC unit: function crc32(crc: cardinal; buf: Pbyte; len: word) a new PASCAL procedure/function modifier, causing a new memory block to be assigned/released for variables each time a procedure/function is called, example 'math\\evaluate.pas'. added ability to disable ROM while maintaining system operation, {$DEFINE ROMOFF} shorter names of the switch -zpage (-z), -stack (-s), -data (-d), -code (-c), -define (-d), -ipath (-i) added possibility to generate code for C64 (-t c64)","title":"1.6.4"},{"location":"#163","text":"fixes, optimizations SYSUTILS: Trim SYSTEM: PByte, PByteArray, PWord GRAPH, FASTGRAPH: TFrameBuffer, DisplayBuffer, FrameBuffer, SwitchBuffer, Scanline BLIBS: unit GR10PP LIB: unit GR4PP","title":"1.6.3"},{"location":"#160-162","text":"new EFAST unit for speeding up character output to E device: SYSTEM: function Copy(var S: String; Index: Byte; Count: Byte): String; SYSTEM: Palette, HPalette added support for one-dimensional arrays of type ^RECORD (pointer to a record) optimization of conditional blocks, the shortest, fastest possible resulting code is generated added PChar type, [link]https://www.freepascal.org/docs-html/rtl/system/pchar.html added ability to return function value by enumeration type added new switch -define:symbol added new switch -ipath:includepath","title":"1.6.0 - 1.6.2"},{"location":"#159-160","text":"SYSTEM: TDateTime GRAPH, FASTGRAPH: Arc, PieSlice, TLastArcCoords, LastArcCoords SYSUTILS: Now, Date, DateToStr, DecodeDate, DecodeDateTime, DecodeTime, EncodeDate, EncodeDateTime, EncodeTime, IsLeapYear, BoolToStr, StrToBool STRUTILS: AddChar, AddCharR, PadLeft, PadRight Added support for {$INCLUDE %DATE%}, {$INCLUDE %TIME%}, [link]https://www.freepascal.org/docs-html/prog/progsu41.html switches -CODE:, -DATE:, -STACK:, -ZPAGE: by default require HEX value without initial '$' character.","title":"1.5.9 - 1.6.0"},{"location":"ados/","text":"Alternative to DOS foxDOS installs the D: device like any other DOS Atari loads a bootable file named AUTORUN at startup supports the standard DOS 2 file system the supported sector size (128 or 256 bytes) is determined at the foxDOS compilation stage foxDOS allows a file to be read by D: supports BINARY LOAD function, e.g. XIO 40,#1,0,0, \"D:FILE.EXE\" foxDOS fits entirely into pre-read sectors (boot sectors) foxDOS does not set MEMLO, but only occupies the memory area $0700..$097F foxDOS does not disable the ROM during transmission limitations: only one file can be read at a time, but it can be of any length allows overwriting an existing file that fits in only one sector other operations such as reading a directory, deleting, renaming, etc. are not supported copy filename.obx disk\\autorun. dir2atr.exe -md -B foxdos.obx disk.atr disk\\ xBootDOS MEMLO = $980, does not use $04xx,$05xx or $06x page after loading, it automatically runs the program stored under the name \"AUTO\" automatically configures itself to the appropriate sector size (128/256) of SD/ED/DD and DOS2 file system version (disk image size up to 16 MB) also supports BiboDOS and TopDOS systems with 64/128 directory entries allows you to overwrite existing files supports BINARY LOAD function, e.g. XIO 40,#1,0,0, \"D:FILE.EXE\" additional NOTE and POINT commands are included in the xBDext file (can be loaded automatically - rename to AUTO) limitations: only one file can be read at a time, but it can be of any length other operations such as reading a directory, deleting, renaming, etc. are not supported copy filename.obx disk\\autorun. dir2atr.exe -md -B xBootDOS.obx disk.atr disk\\ dir2atr A program for Windows with which you can create floppy disk images Atari 8-Bit ATR","title":"Alternative to DOS"},{"location":"ados/#alternative-to-dos","text":"","title":"Alternative to DOS"},{"location":"ados/#foxdos","text":"installs the D: device like any other DOS Atari loads a bootable file named AUTORUN at startup supports the standard DOS 2 file system the supported sector size (128 or 256 bytes) is determined at the foxDOS compilation stage foxDOS allows a file to be read by D: supports BINARY LOAD function, e.g. XIO 40,#1,0,0, \"D:FILE.EXE\" foxDOS fits entirely into pre-read sectors (boot sectors) foxDOS does not set MEMLO, but only occupies the memory area $0700..$097F foxDOS does not disable the ROM during transmission limitations: only one file can be read at a time, but it can be of any length allows overwriting an existing file that fits in only one sector other operations such as reading a directory, deleting, renaming, etc. are not supported copy filename.obx disk\\autorun. dir2atr.exe -md -B foxdos.obx disk.atr disk\\","title":"foxDOS"},{"location":"ados/#xbootdos","text":"MEMLO = $980, does not use $04xx,$05xx or $06x page after loading, it automatically runs the program stored under the name \"AUTO\" automatically configures itself to the appropriate sector size (128/256) of SD/ED/DD and DOS2 file system version (disk image size up to 16 MB) also supports BiboDOS and TopDOS systems with 64/128 directory entries allows you to overwrite existing files supports BINARY LOAD function, e.g. XIO 40,#1,0,0, \"D:FILE.EXE\" additional NOTE and POINT commands are included in the xBDext file (can be loaded automatically - rename to AUTO) limitations: only one file can be read at a time, but it can be of any length other operations such as reading a directory, deleting, renaming, etc. are not supported copy filename.obx disk\\autorun. dir2atr.exe -md -B xBootDOS.obx disk.atr disk\\","title":"xBootDOS"},{"location":"ados/#dir2atr","text":"A program for Windows with which you can create floppy disk images Atari 8-Bit ATR","title":"dir2atr"},{"location":"asm/","text":"ASM The compiler allows two syntaxes for inline assembler blocks: The ASM block, with { } brackets as for a comment and the standard one without brackets. The syntax of the code inside an assembler block is not verified by the compiler. This is done only by Mad-Assembler during the assembly of the *.a65 output file. WARNING: The MOS 6502 CPU register X is used to operate the Mad-Pascal software stack. Therefore an assembler block must restore the original value of X at the end of the block, if the register is modified by the block. ASM lda #10 sta 712 END; ASM { lda #10 sta 712 }; procedure name; assembler; asm lda #10 sta 712 end; procedure name; assembler; asm { lda #10 sta 712 }; end; $LINK {$link filename} The compiler directive {$link filename} allows you to attach a relocatable file from Mad-Assembler to a compiled Mad-Pascal program. .reloc .extrn edx .dword .extrn print .proc (.dword edx) .var .public prc .proc prc (.dword a .dword b .dword c) .var .var a,b,c .dword print a print b print c rts .endp In the above example, we use the PRINT procedure, which is defined in Mad-Pascal . uses crt; procedure prc(a,b,c: integer); external; procedure print(value: dword); keep; register; begin writeln(value); end; {$link test.obx} // link PRC procedure begin prc(11, 347, 321785); repeat until keypressed; end. From the assembler level we have access to Mad-Pascal procedures but only those marked with the modifier REGISTER , i.e. those whose parameters are passed through the program registers EDX , ECX , EAX (we are limited to a maximum of three parameters). The KEEP modifier forces a procedure to remain in the compiled code regardless of whether its use has occurred or not (normally procedures/functions that are not used are eliminated). Mad-Pascal , on the other hand, has access to procedures from the linked assembler file, whose parameters are passed through variables, modifier .VAR . .proc prc (.dword a .dword b .dword c) .var In Mad-Assembler relocatable program, we need an additional declaration of the external symbols EDX , ECX , EAX . .extrn edx, ecx, eax .dword The Mad-Pascal procedure itself, which we want to access from the assembler level, is declared as an external procedure with parameters denoting program registers EDX , ECX , EAX . For more information on the REGISTER modifier and the order in which parameters are allocated in program registers, see Procedures and functions . .extrn print .proc (.dword edx) .var We will access the PRC procedure from the Mad-Pascal level by making it public via the .PUBLIC assembler directive. .public prc After assembling our sample relocatable assembler program TEST.ASM , we get the file TEST.OBX , which we can link to the Mad-Pascal program with the {$LINK} directive. {$link test.obx}","title":"Assembler inlining"},{"location":"asm/#_1","text":"","title":""},{"location":"asm/#asm","text":"The compiler allows two syntaxes for inline assembler blocks: The ASM block, with { } brackets as for a comment and the standard one without brackets. The syntax of the code inside an assembler block is not verified by the compiler. This is done only by Mad-Assembler during the assembly of the *.a65 output file. WARNING: The MOS 6502 CPU register X is used to operate the Mad-Pascal software stack. Therefore an assembler block must restore the original value of X at the end of the block, if the register is modified by the block. ASM lda #10 sta 712 END; ASM { lda #10 sta 712 }; procedure name; assembler; asm lda #10 sta 712 end; procedure name; assembler; asm { lda #10 sta 712 }; end;","title":"ASM"},{"location":"asm/#link","text":"{$link filename} The compiler directive {$link filename} allows you to attach a relocatable file from Mad-Assembler to a compiled Mad-Pascal program. .reloc .extrn edx .dword .extrn print .proc (.dword edx) .var .public prc .proc prc (.dword a .dword b .dword c) .var .var a,b,c .dword print a print b print c rts .endp In the above example, we use the PRINT procedure, which is defined in Mad-Pascal . uses crt; procedure prc(a,b,c: integer); external; procedure print(value: dword); keep; register; begin writeln(value); end; {$link test.obx} // link PRC procedure begin prc(11, 347, 321785); repeat until keypressed; end. From the assembler level we have access to Mad-Pascal procedures but only those marked with the modifier REGISTER , i.e. those whose parameters are passed through the program registers EDX , ECX , EAX (we are limited to a maximum of three parameters). The KEEP modifier forces a procedure to remain in the compiled code regardless of whether its use has occurred or not (normally procedures/functions that are not used are eliminated). Mad-Pascal , on the other hand, has access to procedures from the linked assembler file, whose parameters are passed through variables, modifier .VAR . .proc prc (.dword a .dword b .dword c) .var In Mad-Assembler relocatable program, we need an additional declaration of the external symbols EDX , ECX , EAX . .extrn edx, ecx, eax .dword The Mad-Pascal procedure itself, which we want to access from the assembler level, is declared as an external procedure with parameters denoting program registers EDX , ECX , EAX . For more information on the REGISTER modifier and the order in which parameters are allocated in program registers, see Procedures and functions . .extrn print .proc (.dword edx) .var We will access the PRC procedure from the Mad-Pascal level by making it public via the .PUBLIC assembler directive. .public prc After assembling our sample relocatable assembler program TEST.ASM , we get the file TEST.OBX , which we can link to the Mad-Pascal program with the {$LINK} directive. {$link test.obx}","title":"$LINK"},{"location":"constants/","text":"Ordinary constants The character = is used for the CONST constant declarations. The use of operators: + - * / not and or div mod ord chr sizeof pi is possible in the constant expression to compute the constant value at compile time. Ordinary constants have a variable type and the compiler will convert them to the required type at when they are used. const e = 2.7182818; { Real type constant } a = 2; { Ordinal BYTE type constant } c = '4'; { Character type constant } s = 'atari'; { String type constant } sc = chr(32); ls = SizeOf(cardinal); Typed constants You can also specify the fixed type of a constant explicitly. const f : single = 3.14; x : word = 5; pbox : array [0..1] of word = (12,10); The syntax for specifying the initialization in CONST arrays is the same as VAR arrays. See section Initialization for details.","title":"Constants"},{"location":"constants/#_1","text":"","title":""},{"location":"constants/#ordinary-constants","text":"The character = is used for the CONST constant declarations. The use of operators: + - * / not and or div mod ord chr sizeof pi is possible in the constant expression to compute the constant value at compile time. Ordinary constants have a variable type and the compiler will convert them to the required type at when they are used. const e = 2.7182818; { Real type constant } a = 2; { Ordinal BYTE type constant } c = '4'; { Character type constant } s = 'atari'; { String type constant } sc = chr(32); ls = SizeOf(cardinal);","title":"Ordinary constants"},{"location":"constants/#typed-constants","text":"You can also specify the fixed type of a constant explicitly. const f : single = 3.14; x : word = 5; pbox : array [0..1] of word = (12,10); The syntax for specifying the initialization in CONST arrays is the same as VAR arrays. See section Initialization for details.","title":"Typed constants"},{"location":"essential-libraries/","text":"In the Mad-Pascal LIB there are basic UNIT modules needed for compilation, such as SYSTEM CRT GRAPH SYSUTILS MATH DOS . The module is selected by the USES instructions, e.g.: uses crt, sysutils; The SYSTEM module is added to the USES list by default and compiled first. SYSTEM Constants M_PI_2 = 6.283285; // pi * 2 D_PI_2 = 1.570796; // pi / 2 D_PI_180 = 0.017453; // pi / 180 mGTIA = 0; mVBXE = $80; WINDOW = $10; NARROW = $20; VBXE_XDLADR = $0000; // XDLIST VBXE_MAPADR = $1000; // COLOR MAP ADDRESS VBXE_BCBADR = $0100; // BLITTER LIST ADDRESS VBXE_OVRADR = $5000; // OVERLAY ADDRESS VBXE_WINDOW = $B000; // 4K WINDOW $B000..$BFFF iDLI = 0; iVBL = 1; CH_DELCHR = $FE; CH_ENTER = $9B; CH_ESC = $1B; CH_CURS_UP = 28; CH_CURS_DOWN = 29; CH_CURS_LEFT = 30; CH_CURS_RIGHT = 31; CH_TAB = $7F; CH_EOL = $9B; CH_CLR = $7D; CH_BEL = $FD; CH_DEL = $7E; CH_DELLINE = $9C; CH_INSLINE = $9D; COLOR_BLACK = $00; COLOR_WHITE = $0e; COLOR_RED = $32; COLOR_CYAN = $96; COLOR_VIOLET = $68; COLOR_GREEN = $c4; COLOR_BLUE = $74; COLOR_YELLOW = $ee; COLOR_ORANGE = $4a; COLOR_BROWN = $e4; COLOR_LIGHTRED = $3c; COLOR_GRAY1 = $04; COLOR_GRAY2 = $06; COLOR_GRAY3 = $0a; COLOR_LIGHTGREEN = $cc; COLOR_LIGHTBLUE = $7c; Types TPoint TPoint = record x,y: SmallInt end; Definition of coordinates (X, Y). TRect TRect = record left, top, right, bottom: smallint end; Definition of the position and size of a quadrangle with parameters (left, top) - upper-left corner, (right, bottom) - lower-right corner. TString TString = string[32]; Definition of a short character string used to pass file names, etc. Variables IOResult IOResult: byte; Variable stores the last I/O operation error. Error codes I/O . ScreenWidth ScreenWidth: word = 40 Variable storing the current width of the screen. By default, this is a value of 40 for the editor screen. ScreenHeight: word = 24; ScreenHeight Variable storing the current height of the screen. By default, this is a value of 24 for the editor screen. Procedures and functions Abs ArcTan Assign BinStr Concat Blockread Blockwrite Chr Cos Close Dec DeleteFile DPeek DPoke Eof Exit Exp FilePos FileSize FillChar Frac GetIntVec Halt Hi HexStr Inc Ln Lo LowerCase Move OctStr Odd Ord ParamCount ParamStr Pause Peek Point PointsEqual Poke Pred Random ReadConfig ReadSecto Rect RenameFile Reset Rewrite Round Seek SetLength SetIntVec Sin Succ Space SizeOf Str StringOfChar Sqr Sqrt Trunc UpCase Val WriteSector Abs function Abs(x: real): real; function Abs(x: integer): integer; A function that calculates the absolute value of the given number (ang. Absolute value ). The absolute value of a non-negative number is the same number, and the negative number is the opposite. The function, when given its total argument, returns the result of the total type. ArcTan function ArcTan(x: real): real; Function (arcus tangents) returns the value of the angle whose tangent is x . Assign procedure Assign(var F:File; FileName:string) The procedure assigns a file variable F with a name FileName . To be able to refer to a file, you should always first use the Assign procedure. For further operations, the file is identified by the file variable, not the name. BinStr function BinStr(Value: cardinal; Digits: byte): TString; Function returns character string with binary representation of value Value . Digits specifies the length of the string, which can number a maximum of 32 characters. Concat function Concat(a,b: string): string; assembler function Concat(a: string; b: char): string; assembler; function Concat(a: char; b: string): string; assembler; function Concat(a,b: char): string; The function combines two text strings into a new character string. Blockread procedure BlockRead(var f: file; var Buf; Count: word; var Result: word); The procedure reads from file f into variable Buf , not more than Count bytes, and places the number of actual bytes read into variable Result (which may be smaller than expected, for example, due to the actual length of the file). Blockwrite procedure BlockWrite(var f: file; var Buf; Count: word; var Result: word); The procedure saves to a file from the variable Buf not more than Count bytes. Chr Chr(65); // Returns the char 'A' Chr(90); // Returns the char 'Z' Chr(32); // Returns the char ' ' Writeln(#65); // Character 'A' Writeln(#65#32#65); // Will write 'A Z' Function returns the character Char with the corresponding ATASCII code specified in the parameter. Alternatively with the function Chr , if you want to get the right character, we can use its ATASCII code with a preceding # . Cos function Cos(x: real): real; Cosinus angle, x in Radians. Close procedure Close(var f: file); The procedure for closing the open file of any type. Each file open with the 'Reset' or 'Rewrite' should be closed with procedure 'Close'. Dec procedure Dec(var X [, N: int]); The procedure reduces the value of the parameter X ... 1 or the parameter value N ... X . Parameter can be the type CHAR BYTE WORD CARDINAL . The Dec procedure generates optimal code, it is recommended for use in loops instead of the subtraction operator '-'. dec(tmp); dec(tmp[2]); DeleteFile function DeleteFile(FileName: string): Boolean; The function allows you to delete the file from the disk called Filename , returns TRUE when the operation was successful, FALSE in the event of an error (most often due to the protection against saving or erroneous file name). DPeek function DPeek(a: word): word; This function returns the word from address a . DPoke procedure DPoke(a: word; value: word); This procedure saves the word value to address a . Eof function Eof(var f: file): Boolean; The function returns the logical value True if the end of the file has been reached. Exit Calling of the procedure Exit it immediately leaves the program block where the call occurred. It can be used to leave the loop, exit the procedure/function or the main program. Exp function Exp(x: real): real; Function increasing the number e (=2.71) to the power given by the argument x . FilePos function FilePos(var f: file): cardinal; The function returns the current position of the file. The file cannot be textual and must be open (e.g. command Reset ). The Bits 0..15 returned value is the number of the disk sector, bits 16..23 position in the sector [0..255] . This is the equivalent of instructions NOTE . FileSize function FileSize(var f: file): cardinal; The function returns the length of the file in bytes ( Sparta DOS X ). The file cannot be textual and must be open (e.g. command Reset ). FillChar procedure FillChar(x: pointer; count: word; value: char); The procedure fills in the buffer specified in the parameter x with identical chars or bytes. Parameter value specifies the data, by count - the amount of data that will be assigned to the buffer. var Buffer : array[0..100] of Char; begin FillChar(Buffer, SizeOf(Buffer), 'A'); end. Frac function Frac(x: real): real; Returns the fractional part of the number x in the real form. GetIntVec procedure GetIntVec(intno: byte; var vector: pointer); The procedure reads the address of the interrupt vector according to the INTNO code. Currently, the permissible codes are: iDLI Display List interrupt, iVBL Vertical Blank interrupt. Halt procedure halt; Calling causes an immediate exit from the program. You can (optionally) enter an error code, in the case of MP it is ignored. Hi function Hi(x): byte Function returning the high-byte of parameter x . HexStr function HexStr(Value: cardinal; Digits: byte): TString; The function returns the character string with the hexadecimal representation of Value . Digits determines the length of the string, which can have a maximum of 32 characters. Inc Inc procedure Inc(var X [, N: int]); The procedure increases the value of the parameter X by 1 or by the value of parameter N . The value of the X parameter can be the type CHAR BYTE WORD CARDINAL . The Inc procedure generates optimal code, so it is recommended for use in loops instead of adding + . inc(tmp); inc(tmp[2]); Int function Int(x: real): real; The function returns the total part of the argument that is a real number. Ln function Ln(x: real): real; Natural logarithm function (based on e) from the given number. The argument of the function must be positive ! Lo function Lo(x): byte; Function returning the low-byte of parameter x . LowerCase function LowerCase(a: char): char; Function changing the characters 'A'..'Z' to the corresponding lowercase characters 'a'..'z'. Move procedure Move(source, dest: pointer; count: word); The procedure is used to copy data from the source, Source , to the specified buffer, Dest . The amount of copied data is determined by the Count parameter. OctStr function OctStr(Value: cardinal; Digits: byte): TString; The function returns the character string with the octal representation of value . Digits determines the length of the string, which can have a maximum of 32 characters. Odd function Odd(x: cardinal): Boolean; function Odd(x: integer): Boolean; The function returns the value of True if the number specified in the X parameter is odd, false if it is even. Ord function Ord(X); This function works inversely to Chr . From the given character parameter, its ATASCII value is returned. Ord('A'); // Zwraca 65 Ord('Z'); // Zwraca 90 Ord(' '); // Zwraca 32 ParamCount function ParamCount: byte; The function returns the number of available arguments ( Sparta Dos X , BWDos ), i.e. the maximum index for the ParamStr procedure. ParamCount determines the number of parameters transferred to the program from the command line. ParamStr function ParamStr(Index: byte): TString; The function returns the program parameters ( Sparta Dos X , BWDos ). Index is the parameter number, i.e. the sequence of characters separated by a space. If we run the TEST.EXE program in this way: TEST.EXE parametr1 parametr2 parametr3 To get a parameter3 , enter Index=3 , and to get the parameter1 you need Index=1 . Index=0 is a special argument, then the function returns the drive from which the program was launched, e.g. D1: . Pause procedure Pause; procedure Pause(n: word); The procedure stops the program operation on N * 1.50 seconds. Peek function Peek(a: word): byte; The function returns a byte from the address a . Point function Point(AX, AY: smallint): TPoint; Function uses the parameters AX and AY to create a TPOINT record. PointsEqual function PointsEqual(const P1, P2: TPoint): Boolean; The function checks whether the coordinate values specified in the parameters P1 and P2 are equal. In this case, the function returns the value of True . Poke procedure Poke(a: word; value: byte); The procedure writes value into address a . Pred function Pred(X: TOrdinal): TOrdinal; Predecessor of the X element. Random function Random: Real; assembler; The function returns random value between <0..1> . function Random(range: byte): byte; assembler; The function returns random value between <0 .. range-1> , in the case of Range=0 returns the random value from between <0 .. 255> . function Random(range: smallint): smallint; The function returns a random value between <0 .. range-1> . ReadConfig function ReadConfig(devnum: byte): cardinal; Reading the status of device devnum . The result is four bytes DVSTAT ($02EA..$02ED) . Byte 0 ($02ea): Bit 0:Indicates the last command frame had an error. Bit 1:Checksum, indicates that there was a checksum error in the last command or data frame Bit 2:Indicates that the last operation by the drive was in error. Bit 3:Indicates a write protected diskette. 1=Write protect Bit 4:Indicates the drive motor is on. 1=motor on Bit 5:A one indicates MFM format (double density) Bit 6:Not used Bit 7:Indicates Density and a Half if 1 Byte 1 ($02eb): Bit 0:FDC Busy should always be a 1 Bit 1:FDC Data Request should always be 1 Bit 2:FDC Lost data should always be 1 Bit 3:FDC CRC error, a 0 indicates the last sector read had a CRC error Bit 4:FDC Record not found, a 0 indicates last sector not found Bit 5:FDC record type, a 0 indicates deleted data mark Bit 6:FDC write protect, indicates write protected disk Bit 7:FDC door is open, 0 indicates door is open Byte 2 ($2ec): Timeout value for doing a format. Byte 3 ($2ed): not used, should be zero ReadSector procedure ReadSector(devnum: byte; sector: word; var buf); The procedure reads the Sector sector of disk devnum and saves it into buf buffer. Rect function Rect(ALeft, ATop, ARight, ABottom: smallint): TRect; The function creates a `TRect' record based on parameters. RenameFile function RenameFile(OldName, NewName: string): Boolean; The function allows you to change the name of the Oldname file to the new name Newname , returns TRUE when the operation was successful, FALSE in the event of an error (most often due to protection against saving or erroneous file name). RenameFile('D:OLDNAME.TMP', 'NEWNAME.TMP'); Reset procedure Reset(var f: file; l: Word); The procedure opens an existing file with the name transferred to the f command Assign . Optionally, we can provide the size of the record in bytes l , by default it is 128. Rewrite procedure Rewrite(var f: file; l: Word); The procedure creates and opens a new file. f is the name transferred by means of the Assign command. Optionally, we can provide the size of the record in bytes l , by default it is 128. Round function Round(x: real): integer; The function rounds the given number to the nearest integer. Seek procedure Seek(var f: file; N: cardinal); The procedure sets the position in the file to N . N should be a value returned by FilePos . This is the equivalent of the instructions POINT . SetLength procedure SetLength(var S: string; Len: byte); The procedure sets the length of the sequence S to LEN . SetIntVec procedure SetIntVec(intno: Byte; vector: pointer); The procedure sets the interrupt vector address according to code INTNO . Currently, the permissible codes are: iDLI interrupt DLI, iVBL interrupt VBL. Sin function Sin(x: real): real; Sinus angle x in radians. Succ function Succ(X: TOrdinal): TOrdinal; The successor of the X element. Space function Space(Len: Byte): ^char; The function generates a new character string with a length of Len filled with spaces. SizeOf function SizeOf(X: AnyType): byte; The function returns the size of the given variable (or type) in bytes. Str procedure Str(var X: TNumericType; var S: string); The procedure converts the number X into a string of S . StringOfChar procedure StringOfChar(ch: Char; len: byte): ^char; The function generates a new character string with the length of len filled with ch . Sqr function Sqr(x: real): real; function Sqr(x: integer): integer; Function calculating the square of the given number. Sqrt function Sqrt(x: real): real; function Sqrt(x: single): single; function Sqrt(x: integer): single; Function calculating the square element given number (English Square root ). Trunc function Trunc(x: real): integer; The function returns the whole part of the number in the form of an integer. UpCase function UpCase(a: char): char; A function changes the characters a .. z to the corresponding large characters A .. Z . Val procedure Val(const S: string; var V; var Code: Byte); The procedure converts the string S into the number V . Code will take the value of 0 if there were no erroneous characters, otherwise it will take the signed number that caused a conversion error. WriteSector procedure WriteSector(devnum: byte; sector: word; var buf); The procedure saves the sector sector floppy disks at the Devnum station based on the buff buffer. CRT Constants CN_START_SELECT_OPTION = 0; CN_SELECT_OPTION = 1; CN_START_OPTION = 2; CN_OPTION = 3; CN_START_SELECT = 4; CN_SELECT = 5; CN_START = 6; CN_NONE = 7; Variables Consol Consol: byte absolute $d01f The variable returns the code of the pressed key/keys. TextAttr TextAttr: byte = 0 The variable stores the value that is added to each displayed sign, e.g. Textattr = $80 will cause the characters to be displayed in inverse. WhereX WhereX: byte absolute $54; The variable stores the current horizontal position of the cursor. WhereY WhereY: byte absolute $55; The variable stores the current vertical position of the cursor. Procedures and functions ClrEol ClrScr CursorOff CursorOn Delay DelLine GotoXY InsLine Keypressed NoSound ReadKey Sound TextBackground TextColor ClrEol procedure ClrEol; The procedure cleans the line from the current cursor position to the right side of the screen edge. The cursor position does not change. ClrScr procedure ClrScr; The procedure clears the editor screen, performs the CH_CLR sign code. CursorOff procedure CursorOff; The procedure turns off the cursor. CursorOn procedure CursorOn; The procedure turns on the cursor. Delay procedure Delay(MS: Word); The procedure awaits the given amount of miliseconds MS . Approximately Delay (1000) generates a delay of one second. DelLine procedure DelLine; The procedure deletes the line at the current cursor position, performs the CH_DELLINE character code. GotoXY procedure GotoXY(x, y: byte); The procedure sets the new cursor position. InsLine procedure InsLine; The procedure inserts an empty line in the current cursor position, performs the CH_INSLIN sign code. Keypressed function Keypressed: Boolean; The function returns the TRUE when a keyboard key has been pressed, otherwise it returns FALSE . NoSound procedure NoSound; The procedure silences the channels of both POKEY-i $D200 $D210) . ReadKey function ReadKey: char; The function returns the code of the keyboard key. Sound procedure Sound(Chan,Freq,Dist,Vol: byte); The procedure reproduces the sound on the POKEY-a CHAN (0..3, 4..7) , with a frequency of FREQ (0..255) , filters DIST (0..7) ,volume VOL (0..15) . TextBackground procedure TextBackground(a: byte); The procedure sets a new color background color (works best with VBXE ). TextColor procedure TextColor(a: byte); The procedure sets a new text color (works best with VBXE ). GRAPH Constants { graphic drivers } D1bit = 11; D2bit = 12; D4bit = 13; D6bit = 14; // 64 colors Half-brite mode - Amiga D8bit = 15; D12bit = 16; // 4096 color modes HAM mode - Amiga m640x480 = 8 + 16; { error codes } grOK = 0; grNoInitGraph = -1; grNotDetected = -2; grFileNotFound = -3; grInvalidDriver = -4; grNoLoadMem = -5; grNoScanMem = -6; grNoFloodMem = -7; grFontNotFound = -8; grNoFontMem = -9; grInvalidMode = -10; grError = -11; grIOerror = -12; grInvalidFont = -13; grInvalidFontNum = -14; grInvalidVersion = -18; Variables GraphResult GraphResult : byte Procedures and functions Bar Bar3D Circle ClipLine Ellipse FillEllipse FillRect FloodFill GetColor GetMaxX GetMaxY GetPixel GetX GetY InitGraph Line LineTo MoveRel MoveTo PutPixel Rectangle SetBkColor SetClipRect SetColor SetColorMapEntry SetColorMapDimensions Bar procedure Bar(x1, y1, x2, y2: Smallint); A rectangle, e.g. for bolts. Bar3D procedure Bar3D(x1, y1, x2, y2: smallint; depth: word; top: boolean); Post for three-dimensional charts. Circle procedure Circle(x0,y0,radius: word); Circle. ClipLine procedure ClipLine(x1, y1, x2, y2: smallint); Ellipse procedure Ellipse(x0, y0, a, b: word); Ellipse. FillEllipse procedure FillEllipse(x0, y0, a, b: word); Ellipse filled inside. FillRect procedure FillRect(Rect: TRect); A rectangle filled inside. FloodFill procedure FloodFill(x, y: smallint; color: byte); Filling the closed area of the screen. GetColor function GetColor: byte; assembler; Specify the current drawing color. GetMaxX function GetMaxX: word; Fetch the highest X coordinate value on the screen. GetMaxY function GetMaxY: word; Fetch the highest Y coordinate value on the screen. GetPixel function GetPixel(x,y: smallint): byte; Fetch the color of a given point on the screen. GetX function GetX: smallint; Get the current X coordinate of the graphic cursor. GetY function GetY: smallint; Get the current Y coordinate of the graphic cursor. InitGraph procedure InitGraph(mode: byte); procedure InitGraph(driver, mode: byte; pth: TString); Initiate graphic mode. Line procedure Line(x0, y0, x1, y1: smallint); A straight line. LineTo procedure LineTo(x, y: smallint); The line from the current position of the cursor to the indicated point. MoveRel procedure MoveRel(Dx, Dy: smallint); Move the graphic cursor by a relative distance. MoveTo procedure MoveTo(x, y: smallint); Move the graphic cursor to the indicated point. PutPixel procedure PutPixel(x,y: smallint); procedure PutPixel(x,y: smallint; color: byte); Light the point on the screen. Rectangle procedure Rectangle(x1, y1, x2, y2: smallint); procedure Rectangle(Rect: TRect); Rectangle. SetBkColor procedure SetBkColor(color: byte); Set the background color. SetClipRect procedure SetClipRect(x0,y0,x1,y1: smallint); procedure SetClipRect(Rect: TRect); SetColor procedure SetColor(color: byte); Set the pen color. SetColorMapEntry procedure SetColorMapEntry; procedure SetColorMapEntry(a,b,c: byte); SetColorMapDimensions procedure SetColorMapDimensions(w,h: byte); SYSUTILS Constants faReadOnly = $01; faHidden = $02; faSysFile = $04; faVolumeID = $08; faDirectory = $10; faArchive = $20; faAnyFile = $3f; Types TSearchRec TSearchRec = record Attr: Byte; Name: TString; FindHandle: Pointer; end; Procedures and functions AnsiUpperCase Beep Click DeleteFile ExtractFileExt FileExists FindFirst FindNext FindClose GetTickCount IntToHex IntToStr RenameFile StrToFloat StrToInt AnsiUpperCase function AnsiUpperCase(const a: string): string; The function converts the characters from the a string. Beep procedure Beep; Beep signal (Buzzer). Click procedure Click; Keyboard signal. DeleteFile function DeleteFile(var FileName: TString): Boolean; The function will delete the file specified in the FileName parameter, returns True when the operation was successful. ExtractFileExt function ExtractFileExt(const FileName: string): TString; Based on the file name or full path to the file specified in the FileName parameter, the function returns the extension (preceded by a dot - e.g. .txt ). FileExists function FileExists(const FileName: string): Boolean; The function checks that the file specified in the FileName parameter exists or not. FindFirst function FindFirst(const FileMask: TString; Attributes: Byte; var SearchResult: TSearchRec): byte; The function searches for files matching the FileMask pattern and with attributes specified in Attributes . If files that match the template were found, the first of them is returned in the variable SerchResult . FindNext function FindNext(var f: TSearchRec): byte; The function goes to the next record found earlier with the help of FindFirst . The parameter must be provided with a record that was previously used in the FindFirst function. FindClose procedure FindClose(var f: TSearchRec); The procedure releases resources (memory) utilized by the FindFirst function. This procedure should be called each time after the search process is completed. GetTickCount function GetTickCount: cardinal; GetTickCount returns the 24-bit time counter (PEEK(RTCLOK+2) + PEEK(RTCLOK+1)*256 + PEEK(RTCLOK)*65536) . This is useful for measuring time. IntToHex function IntToHex(Value: cardinal; Digits: byte): TString; The function converts the numerical value to its hexadecimal string equivalent. IntToStr function IntToStr(a: integer): ^char; The function is used to convert the whole number given in the parameter to string format. RenameFile function RenameFile(var OldName,NewName: TString): Boolean; The function tries to change the file name specified in the OldName parameter to NewName . If the operation is succeeded, the function will return the value of True otherwise False . It may happen that the function will not be able to change the name (e.g. when the application has no right to it) - then the function will return False . StrToFloat function StrToFloat(var s: TString): real; The function converts the string to the Real floating point form. StrToInt function StrToInt(const S: char): byte; function StrToInt (const S: TString): integer; The function is used to convert the text saved in the S variable to an integer - if possible. VBXE The memory map for VBXE is defined in the SYSTEM module. VBXE_XDLADR = $0000; // XDLIST VBXE_MAPADR = $1000; // COLOR MAP ADDRESS VBXE_BCBADR = $0100; // BLITTER LIST ADDRESS VBXE_OVRADR = $5000; // OVERLAY ADDRESS VBXE_WINDOW = $B000; // 4K WINDOW $B000..$BFFF Constants LoRes = 1; // 160x240x256c MedRes = 2; // 320x240x256c HiRes = 3; // 640x240x16c Types TUInt24 record byte0: byte; byte1: byte; byte2: byte; end; 24-bit type used to define memory addresses VBXE . TXDL record xdlc_: word; rptl_: byte; xdlc: word; rptl: byte; ov_adr: TUInt24; ov_step: word; mp_adr: TUInt24; mp_step: word; mp_hscrol: byte; mp_vscrol: byte; mp_width: byte; mp_height: byte; ov_width: byte; ov_prior: byte; end; Type TXDL used by the procedures GetXDL and SetXDL . It allows you to modify the program for VBXE used by Mad-Pascal . TBCB record src_adr: TUInt24; src_step_y: smallint; src_step_x: shortint; dst_adr: TUInt24; dst_step_y: smallint; dst_step_x: shortint; blt_width: word; blt_height: byte; blt_and_mask: byte; blt_xor_mask: byte; blt_collision_mask: byte; blt_zoom: byte; pattern_feature: byte; blt_control: byte; end; Type TBCB (21 bytes), Blitter Code Block . Definition of the Blitter block type Blitter VBXE . TVBXEMemoryStream Object Position: cardinal; Size: cardinal; // 0..Size-1 procedure Create; procedure Clear; procedure SetBank; procedure ReadBuffer(var Buffer; Count: word); procedure WriteBuffer(var Buffer; Count: word); function ReadByte: Byte; function ReadWord: Word; function ReadDWord: Cardinal; procedure WriteByte(b: Byte); procedure WriteWord(w: Word); procedure WriteDWord(d: Cardinal); end; The TVBXEMemoryStream object allows for linear access to memory VBXE . Procedures and functions BlitterBusy ColorMapOff ColorMapOn DstBCB ExtractFileExt GetXDL IniBCB OverlayOff RunBCB SetHorizontalRes VBXEMemoryBank SetXDL SrcBCB VBXEControl VBXEOff BlitterBusy function BlitterBusy: Boolean; assembler; The function returns True if Blitter VBXE is occupied by performing a Blitter program. ColorMapOff procedure ColorMapOff; assembler; Turning off the color map in the XDLIST for VBXE . ColorMapOn procedure ColorMapOn; assembler; Turning on the color map in the XDLIST for VBXE . DstBCB procedure DstBCB(var a: TBCB; dst: cardinal); The procedure amending the target address dst in the Blitter program a . GetXDL procedure GetXDL(var a: txdl); register; assembler; The procedure prescribes to the variable A program XDLIST from the address VBXE_XDLADR in memory VBXE . IniBCB procedure IniBCB(var a: TBCB; src,dst: cardinal; w0, w1: smallint; w: word; h: byte; ctrl: byte); The procedure allows you to initiate memory for the Blitter program at A . Additional parameters specify the address from which the SRC data will be copied, the target address of the copied data DST , width of W0 , target W1 target window, size of the result window, its width W , height H , and to specify the final parameters of the Blitter block CTRL (Bit 3 CTRL is set up to the Blitter reading of the next program and its implementation). OverlayOff procedure OverlayOff; assembler; Disabling overlay mode in the XDLIST . RunBCB procedure RunBCB(var a: TBCB); assembler; Blitter starting VBXE based on the A program. SetHorizontalRes procedure SetHorizontalRes(a: byte); assembler; procedure SetHRes(a: byte); assembler; Establishment of overlay mode in the XDLIST program. VBXEMemoryBank procedure VBXEMemoryBank(b: byte); assembler; Turning on 4K Bank VBXE in the memory window of the Atari 8-Bit $B000..$BCFF . SetXDL procedure SetXDL(var a: txdl); register; assembler; The procedure rewrites the A program to VBXE_XDLADR in memory VBXE . SrcBCB procedure SrcBCB(var a: TBCB; src: cardinal); Procedure amending the source address SRC_ADR in the Blitter program A . VBXEControl procedure VBXEControl(a: byte); assembler; The procedure sets the value of FX_VIDEO_CONTROL . VBXEOff procedure VBXEOff Disable, reset VBXE . MATH Procedures and functions ArcCos ArcSin ArcTan2 Ceil CycleToRad DegNormalize DegToGrad DegToRad DivMod EnsureRange Floor FMod GradToDeg GradToRad InRange IsNan Log2 Log10 LogN Max Min Power RadToCycle RadToDeg RadToGrad RandG RandomRange RandomRangeF Tan ArcCos function ArcCos(x: real): real; Arccos is the opposite function for the COS function. The value of the parameter X must belong to the interval of both sides of the range <-1; 1> . The value returned by the function is the angle from <0; ?> expressed in the radians. ArcSin function ArcSin(x: real): real; The function is used to calculate the mathematical function of the Arcus Sinus with the number X . This is the opposite function to the sine function, i.e. sin(arcsin(x)) = x . ArcTan2 function ArcTan2(y, x: real) : real; The function calculates Arcus Tangens (the opposite of Tangens) from the number Y/X and returns the value in radians. Ceil function Ceil(a: real): smallint; The function returns the smallest integer larger than or equal to the one given in the parameter. CycleToRad function CycleToRad(cycle : real) : real; The function converts the value of the angle expressed in cycles (revolutions) into an angle expressed in radians. DegNormalize function DegNormalize(deg : real) : real; DegToGrad function DegToGrad(deg : real) : real; The function converts the value of the angle expressed in the degree of angle expressed in gradians. DegToRad function DegToRad(deg : real) : real; The function converts the value of the angle expressed in the degree of angle expressed in the arc, i.e. radians. DivMod procedure DivMod(Dividend: integer; Divisor: Word; var r, Remainder: Word); procedure DivMod(Dividend: integer; Divisor: Word; var r, Remainder: smallint); EnsureRange function EnsureRange(const AValue, AMin, AMax: byte): Integer; function EnsureRange(const AValue, AMin, AMax: Integer): Integer; Floor function Floor(a: real): smallint; The function returns the nearest integers less or equal to the one given in the parameter. FMod function FMod(a, b: real): real; The function returns the rest of the division of two real numbers. GradToDeg function GradToDeg(grad : real) : real; The function converts the value of the angle expressed in gradians into the angle expressed in the degrees. GradToRad function GradToRad(grad : real) : real; The GradToRad function converts the value of the angle expressed in gradians into the angle expressed in radians. InRange function InRange(const AValue, AMin, AMax: byte): Boolean; function InRange(const AValue, AMin, AMax: Integer): Boolean; IsNan function IsNan(const d : Single): Boolean; The function checks whether the value of the parameter D is a proper number. Log2 function log2(x : single): single; The function returns the logarithm value at base 2 for the real parameter X >0. Log10 function log10(x : single): single; The function returns the value of the decimal logarithm (logarithm at base 10) for the real parameter X >0. LogN function logN(n,x : single): single; The function returns the logarithm value at the base N >0 for the real parameter X >0. Max function Max(a, b: real): real; function Max(a, b: integer): integer; The overloaded function compares the values of two parameters: A and B , and returns the one that is larger. Min function Min(a, b: real): real; function Min(a, b: integer): integer; The overloaded function compares the values of two parameters A and B , and returns the value of the smaller one. Power function Power(base : real; const exponent : shortint): real; power(base : integer; const exponent : shortint): integer; The function increases the number to any power N, power can be a fraction. RadToCycle function RadToCycle(rad : real) : real; The function converts the value of the angle expressed in radians into an angle expressed in cycles (revolutions). RadToDeg function RadToDeg(rad : real) : real; The function converts the value of the angle expressed in radians into an angle expressed in degrees (DEG). RadToGrad function RadToGrad(rad : real) : real; The function converts the value of the angle expressed in radians into an angle expressed in gradians. RandG function RandG(mean, StdDev : single) : single; RandG is represented by a pseudo-number generator with the distribution Gaussa around the average mean . The StdDev parameter is the standard deviation of the generated numbers from the average value of mean . RandomRange function RandomRange(const aFrom, aTo: smallint): smallint; The function returns a random number from the AFrom - ATo range, including the value of ATo . RandomRangeF function RandomRangeF(const min, max: single): single; Tan function Tan(x: Real): Real; The function returns the value of the angle tangent given in the X parameter.","title":"Essential libraries"},{"location":"essential-libraries/#_1","text":"In the Mad-Pascal LIB there are basic UNIT modules needed for compilation, such as SYSTEM CRT GRAPH SYSUTILS MATH DOS . The module is selected by the USES instructions, e.g.: uses crt, sysutils; The SYSTEM module is added to the USES list by default and compiled first.","title":""},{"location":"essential-libraries/#system","text":"","title":"SYSTEM"},{"location":"essential-libraries/#constants","text":"M_PI_2 = 6.283285; // pi * 2 D_PI_2 = 1.570796; // pi / 2 D_PI_180 = 0.017453; // pi / 180 mGTIA = 0; mVBXE = $80; WINDOW = $10; NARROW = $20; VBXE_XDLADR = $0000; // XDLIST VBXE_MAPADR = $1000; // COLOR MAP ADDRESS VBXE_BCBADR = $0100; // BLITTER LIST ADDRESS VBXE_OVRADR = $5000; // OVERLAY ADDRESS VBXE_WINDOW = $B000; // 4K WINDOW $B000..$BFFF iDLI = 0; iVBL = 1; CH_DELCHR = $FE; CH_ENTER = $9B; CH_ESC = $1B; CH_CURS_UP = 28; CH_CURS_DOWN = 29; CH_CURS_LEFT = 30; CH_CURS_RIGHT = 31; CH_TAB = $7F; CH_EOL = $9B; CH_CLR = $7D; CH_BEL = $FD; CH_DEL = $7E; CH_DELLINE = $9C; CH_INSLINE = $9D; COLOR_BLACK = $00; COLOR_WHITE = $0e; COLOR_RED = $32; COLOR_CYAN = $96; COLOR_VIOLET = $68; COLOR_GREEN = $c4; COLOR_BLUE = $74; COLOR_YELLOW = $ee; COLOR_ORANGE = $4a; COLOR_BROWN = $e4; COLOR_LIGHTRED = $3c; COLOR_GRAY1 = $04; COLOR_GRAY2 = $06; COLOR_GRAY3 = $0a; COLOR_LIGHTGREEN = $cc; COLOR_LIGHTBLUE = $7c;","title":"Constants"},{"location":"essential-libraries/#types","text":"","title":"Types"},{"location":"essential-libraries/#tpoint","text":"TPoint = record x,y: SmallInt end; Definition of coordinates (X, Y).","title":"TPoint"},{"location":"essential-libraries/#trect","text":"TRect = record left, top, right, bottom: smallint end; Definition of the position and size of a quadrangle with parameters (left, top) - upper-left corner, (right, bottom) - lower-right corner.","title":"TRect"},{"location":"essential-libraries/#tstring","text":"TString = string[32]; Definition of a short character string used to pass file names, etc.","title":"TString"},{"location":"essential-libraries/#variables","text":"","title":"Variables"},{"location":"essential-libraries/#ioresult","text":"IOResult: byte; Variable stores the last I/O operation error. Error codes I/O .","title":"IOResult"},{"location":"essential-libraries/#screenwidth","text":"ScreenWidth: word = 40 Variable storing the current width of the screen. By default, this is a value of 40 for the editor screen. ScreenHeight: word = 24;","title":"ScreenWidth"},{"location":"essential-libraries/#screenheight","text":"Variable storing the current height of the screen. By default, this is a value of 24 for the editor screen.","title":"ScreenHeight"},{"location":"essential-libraries/#procedures-and-functions","text":"Abs ArcTan Assign BinStr Concat Blockread Blockwrite Chr Cos Close Dec DeleteFile DPeek DPoke Eof Exit Exp FilePos FileSize FillChar Frac GetIntVec Halt Hi HexStr Inc Ln Lo LowerCase Move OctStr Odd Ord ParamCount ParamStr Pause Peek Point PointsEqual Poke Pred Random ReadConfig ReadSecto Rect RenameFile Reset Rewrite Round Seek SetLength SetIntVec Sin Succ Space SizeOf Str StringOfChar Sqr Sqrt Trunc UpCase Val WriteSector","title":"Procedures and functions"},{"location":"essential-libraries/#abs","text":"function Abs(x: real): real; function Abs(x: integer): integer; A function that calculates the absolute value of the given number (ang. Absolute value ). The absolute value of a non-negative number is the same number, and the negative number is the opposite. The function, when given its total argument, returns the result of the total type.","title":"Abs"},{"location":"essential-libraries/#arctan","text":"function ArcTan(x: real): real; Function (arcus tangents) returns the value of the angle whose tangent is x .","title":"ArcTan"},{"location":"essential-libraries/#assign","text":"procedure Assign(var F:File; FileName:string) The procedure assigns a file variable F with a name FileName . To be able to refer to a file, you should always first use the Assign procedure. For further operations, the file is identified by the file variable, not the name.","title":"Assign"},{"location":"essential-libraries/#binstr","text":"function BinStr(Value: cardinal; Digits: byte): TString; Function returns character string with binary representation of value Value . Digits specifies the length of the string, which can number a maximum of 32 characters.","title":"BinStr"},{"location":"essential-libraries/#concat","text":"function Concat(a,b: string): string; assembler function Concat(a: string; b: char): string; assembler; function Concat(a: char; b: string): string; assembler; function Concat(a,b: char): string; The function combines two text strings into a new character string.","title":"Concat"},{"location":"essential-libraries/#blockread","text":"procedure BlockRead(var f: file; var Buf; Count: word; var Result: word); The procedure reads from file f into variable Buf , not more than Count bytes, and places the number of actual bytes read into variable Result (which may be smaller than expected, for example, due to the actual length of the file).","title":"Blockread"},{"location":"essential-libraries/#blockwrite","text":"procedure BlockWrite(var f: file; var Buf; Count: word; var Result: word); The procedure saves to a file from the variable Buf not more than Count bytes.","title":"Blockwrite"},{"location":"essential-libraries/#chr","text":"Chr(65); // Returns the char 'A' Chr(90); // Returns the char 'Z' Chr(32); // Returns the char ' ' Writeln(#65); // Character 'A' Writeln(#65#32#65); // Will write 'A Z' Function returns the character Char with the corresponding ATASCII code specified in the parameter. Alternatively with the function Chr , if you want to get the right character, we can use its ATASCII code with a preceding # .","title":"Chr"},{"location":"essential-libraries/#cos","text":"function Cos(x: real): real; Cosinus angle, x in Radians.","title":"Cos"},{"location":"essential-libraries/#close","text":"procedure Close(var f: file); The procedure for closing the open file of any type. Each file open with the 'Reset' or 'Rewrite' should be closed with procedure 'Close'.","title":"Close"},{"location":"essential-libraries/#dec","text":"procedure Dec(var X [, N: int]); The procedure reduces the value of the parameter X ... 1 or the parameter value N ... X . Parameter can be the type CHAR BYTE WORD CARDINAL . The Dec procedure generates optimal code, it is recommended for use in loops instead of the subtraction operator '-'. dec(tmp); dec(tmp[2]);","title":"Dec"},{"location":"essential-libraries/#deletefile","text":"function DeleteFile(FileName: string): Boolean; The function allows you to delete the file from the disk called Filename , returns TRUE when the operation was successful, FALSE in the event of an error (most often due to the protection against saving or erroneous file name).","title":"DeleteFile"},{"location":"essential-libraries/#dpeek","text":"function DPeek(a: word): word; This function returns the word from address a .","title":"DPeek"},{"location":"essential-libraries/#dpoke","text":"procedure DPoke(a: word; value: word); This procedure saves the word value to address a .","title":"DPoke"},{"location":"essential-libraries/#eof","text":"function Eof(var f: file): Boolean; The function returns the logical value True if the end of the file has been reached.","title":"Eof"},{"location":"essential-libraries/#exit","text":"Calling of the procedure Exit it immediately leaves the program block where the call occurred. It can be used to leave the loop, exit the procedure/function or the main program.","title":"Exit"},{"location":"essential-libraries/#exp","text":"function Exp(x: real): real; Function increasing the number e (=2.71) to the power given by the argument x .","title":"Exp"},{"location":"essential-libraries/#filepos","text":"function FilePos(var f: file): cardinal; The function returns the current position of the file. The file cannot be textual and must be open (e.g. command Reset ). The Bits 0..15 returned value is the number of the disk sector, bits 16..23 position in the sector [0..255] . This is the equivalent of instructions NOTE .","title":"FilePos"},{"location":"essential-libraries/#filesize","text":"function FileSize(var f: file): cardinal; The function returns the length of the file in bytes ( Sparta DOS X ). The file cannot be textual and must be open (e.g. command Reset ).","title":"FileSize"},{"location":"essential-libraries/#fillchar","text":"procedure FillChar(x: pointer; count: word; value: char); The procedure fills in the buffer specified in the parameter x with identical chars or bytes. Parameter value specifies the data, by count - the amount of data that will be assigned to the buffer. var Buffer : array[0..100] of Char; begin FillChar(Buffer, SizeOf(Buffer), 'A'); end.","title":"FillChar"},{"location":"essential-libraries/#frac","text":"function Frac(x: real): real; Returns the fractional part of the number x in the real form.","title":"Frac"},{"location":"essential-libraries/#getintvec","text":"procedure GetIntVec(intno: byte; var vector: pointer); The procedure reads the address of the interrupt vector according to the INTNO code. Currently, the permissible codes are: iDLI Display List interrupt, iVBL Vertical Blank interrupt.","title":"GetIntVec"},{"location":"essential-libraries/#halt","text":"procedure halt; Calling causes an immediate exit from the program. You can (optionally) enter an error code, in the case of MP it is ignored.","title":"Halt"},{"location":"essential-libraries/#hi","text":"function Hi(x): byte Function returning the high-byte of parameter x .","title":"Hi"},{"location":"essential-libraries/#hexstr","text":"function HexStr(Value: cardinal; Digits: byte): TString; The function returns the character string with the hexadecimal representation of Value . Digits determines the length of the string, which can have a maximum of 32 characters.","title":"HexStr"},{"location":"essential-libraries/#inc","text":"Inc procedure Inc(var X [, N: int]); The procedure increases the value of the parameter X by 1 or by the value of parameter N . The value of the X parameter can be the type CHAR BYTE WORD CARDINAL . The Inc procedure generates optimal code, so it is recommended for use in loops instead of adding + . inc(tmp); inc(tmp[2]);","title":"Inc"},{"location":"essential-libraries/#int","text":"function Int(x: real): real; The function returns the total part of the argument that is a real number.","title":"Int"},{"location":"essential-libraries/#ln","text":"function Ln(x: real): real; Natural logarithm function (based on e) from the given number. The argument of the function must be positive !","title":"Ln"},{"location":"essential-libraries/#lo","text":"function Lo(x): byte; Function returning the low-byte of parameter x .","title":"Lo"},{"location":"essential-libraries/#lowercase","text":"function LowerCase(a: char): char; Function changing the characters 'A'..'Z' to the corresponding lowercase characters 'a'..'z'.","title":"LowerCase"},{"location":"essential-libraries/#move","text":"procedure Move(source, dest: pointer; count: word); The procedure is used to copy data from the source, Source , to the specified buffer, Dest . The amount of copied data is determined by the Count parameter.","title":"Move"},{"location":"essential-libraries/#octstr","text":"function OctStr(Value: cardinal; Digits: byte): TString; The function returns the character string with the octal representation of value . Digits determines the length of the string, which can have a maximum of 32 characters.","title":"OctStr"},{"location":"essential-libraries/#odd","text":"function Odd(x: cardinal): Boolean; function Odd(x: integer): Boolean; The function returns the value of True if the number specified in the X parameter is odd, false if it is even.","title":"Odd"},{"location":"essential-libraries/#ord","text":"function Ord(X); This function works inversely to Chr . From the given character parameter, its ATASCII value is returned. Ord('A'); // Zwraca 65 Ord('Z'); // Zwraca 90 Ord(' '); // Zwraca 32","title":"Ord"},{"location":"essential-libraries/#paramcount","text":"function ParamCount: byte; The function returns the number of available arguments ( Sparta Dos X , BWDos ), i.e. the maximum index for the ParamStr procedure. ParamCount determines the number of parameters transferred to the program from the command line.","title":"ParamCount"},{"location":"essential-libraries/#paramstr","text":"function ParamStr(Index: byte): TString; The function returns the program parameters ( Sparta Dos X , BWDos ). Index is the parameter number, i.e. the sequence of characters separated by a space. If we run the TEST.EXE program in this way: TEST.EXE parametr1 parametr2 parametr3 To get a parameter3 , enter Index=3 , and to get the parameter1 you need Index=1 . Index=0 is a special argument, then the function returns the drive from which the program was launched, e.g. D1: .","title":"ParamStr"},{"location":"essential-libraries/#pause","text":"procedure Pause; procedure Pause(n: word); The procedure stops the program operation on N * 1.50 seconds.","title":"Pause"},{"location":"essential-libraries/#peek","text":"function Peek(a: word): byte; The function returns a byte from the address a .","title":"Peek"},{"location":"essential-libraries/#point","text":"function Point(AX, AY: smallint): TPoint; Function uses the parameters AX and AY to create a TPOINT record.","title":"Point"},{"location":"essential-libraries/#pointsequal","text":"function PointsEqual(const P1, P2: TPoint): Boolean; The function checks whether the coordinate values specified in the parameters P1 and P2 are equal. In this case, the function returns the value of True .","title":"PointsEqual"},{"location":"essential-libraries/#poke","text":"procedure Poke(a: word; value: byte); The procedure writes value into address a .","title":"Poke"},{"location":"essential-libraries/#pred","text":"function Pred(X: TOrdinal): TOrdinal; Predecessor of the X element.","title":"Pred"},{"location":"essential-libraries/#random","text":"function Random: Real; assembler; The function returns random value between <0..1> . function Random(range: byte): byte; assembler; The function returns random value between <0 .. range-1> , in the case of Range=0 returns the random value from between <0 .. 255> . function Random(range: smallint): smallint; The function returns a random value between <0 .. range-1> .","title":"Random"},{"location":"essential-libraries/#readconfig","text":"function ReadConfig(devnum: byte): cardinal; Reading the status of device devnum . The result is four bytes DVSTAT ($02EA..$02ED) . Byte 0 ($02ea): Bit 0:Indicates the last command frame had an error. Bit 1:Checksum, indicates that there was a checksum error in the last command or data frame Bit 2:Indicates that the last operation by the drive was in error. Bit 3:Indicates a write protected diskette. 1=Write protect Bit 4:Indicates the drive motor is on. 1=motor on Bit 5:A one indicates MFM format (double density) Bit 6:Not used Bit 7:Indicates Density and a Half if 1 Byte 1 ($02eb): Bit 0:FDC Busy should always be a 1 Bit 1:FDC Data Request should always be 1 Bit 2:FDC Lost data should always be 1 Bit 3:FDC CRC error, a 0 indicates the last sector read had a CRC error Bit 4:FDC Record not found, a 0 indicates last sector not found Bit 5:FDC record type, a 0 indicates deleted data mark Bit 6:FDC write protect, indicates write protected disk Bit 7:FDC door is open, 0 indicates door is open Byte 2 ($2ec): Timeout value for doing a format. Byte 3 ($2ed): not used, should be zero","title":"ReadConfig"},{"location":"essential-libraries/#readsector","text":"procedure ReadSector(devnum: byte; sector: word; var buf); The procedure reads the Sector sector of disk devnum and saves it into buf buffer.","title":"ReadSector"},{"location":"essential-libraries/#rect","text":"function Rect(ALeft, ATop, ARight, ABottom: smallint): TRect; The function creates a `TRect' record based on parameters.","title":"Rect"},{"location":"essential-libraries/#renamefile","text":"function RenameFile(OldName, NewName: string): Boolean; The function allows you to change the name of the Oldname file to the new name Newname , returns TRUE when the operation was successful, FALSE in the event of an error (most often due to protection against saving or erroneous file name). RenameFile('D:OLDNAME.TMP', 'NEWNAME.TMP');","title":"RenameFile"},{"location":"essential-libraries/#reset","text":"procedure Reset(var f: file; l: Word); The procedure opens an existing file with the name transferred to the f command Assign . Optionally, we can provide the size of the record in bytes l , by default it is 128.","title":"Reset"},{"location":"essential-libraries/#rewrite","text":"procedure Rewrite(var f: file; l: Word); The procedure creates and opens a new file. f is the name transferred by means of the Assign command. Optionally, we can provide the size of the record in bytes l , by default it is 128.","title":"Rewrite"},{"location":"essential-libraries/#round","text":"function Round(x: real): integer; The function rounds the given number to the nearest integer.","title":"Round"},{"location":"essential-libraries/#seek","text":"procedure Seek(var f: file; N: cardinal); The procedure sets the position in the file to N . N should be a value returned by FilePos . This is the equivalent of the instructions POINT .","title":"Seek"},{"location":"essential-libraries/#setlength","text":"procedure SetLength(var S: string; Len: byte); The procedure sets the length of the sequence S to LEN .","title":"SetLength"},{"location":"essential-libraries/#setintvec","text":"procedure SetIntVec(intno: Byte; vector: pointer); The procedure sets the interrupt vector address according to code INTNO . Currently, the permissible codes are: iDLI interrupt DLI, iVBL interrupt VBL.","title":"SetIntVec"},{"location":"essential-libraries/#sin","text":"function Sin(x: real): real; Sinus angle x in radians.","title":"Sin"},{"location":"essential-libraries/#succ","text":"function Succ(X: TOrdinal): TOrdinal; The successor of the X element.","title":"Succ"},{"location":"essential-libraries/#space","text":"function Space(Len: Byte): ^char; The function generates a new character string with a length of Len filled with spaces.","title":"Space"},{"location":"essential-libraries/#sizeof","text":"function SizeOf(X: AnyType): byte; The function returns the size of the given variable (or type) in bytes.","title":"SizeOf"},{"location":"essential-libraries/#str","text":"procedure Str(var X: TNumericType; var S: string); The procedure converts the number X into a string of S .","title":"Str"},{"location":"essential-libraries/#stringofchar","text":"procedure StringOfChar(ch: Char; len: byte): ^char; The function generates a new character string with the length of len filled with ch .","title":"StringOfChar"},{"location":"essential-libraries/#sqr","text":"function Sqr(x: real): real; function Sqr(x: integer): integer; Function calculating the square of the given number.","title":"Sqr"},{"location":"essential-libraries/#sqrt","text":"function Sqrt(x: real): real; function Sqrt(x: single): single; function Sqrt(x: integer): single; Function calculating the square element given number (English Square root ).","title":"Sqrt"},{"location":"essential-libraries/#trunc","text":"function Trunc(x: real): integer; The function returns the whole part of the number in the form of an integer.","title":"Trunc"},{"location":"essential-libraries/#upcase","text":"function UpCase(a: char): char; A function changes the characters a .. z to the corresponding large characters A .. Z .","title":"UpCase"},{"location":"essential-libraries/#val","text":"procedure Val(const S: string; var V; var Code: Byte); The procedure converts the string S into the number V . Code will take the value of 0 if there were no erroneous characters, otherwise it will take the signed number that caused a conversion error.","title":"Val"},{"location":"essential-libraries/#writesector","text":"procedure WriteSector(devnum: byte; sector: word; var buf); The procedure saves the sector sector floppy disks at the Devnum station based on the buff buffer.","title":"WriteSector"},{"location":"essential-libraries/#crt","text":"","title":"CRT"},{"location":"essential-libraries/#constants_1","text":"CN_START_SELECT_OPTION = 0; CN_SELECT_OPTION = 1; CN_START_OPTION = 2; CN_OPTION = 3; CN_START_SELECT = 4; CN_SELECT = 5; CN_START = 6; CN_NONE = 7;","title":"Constants"},{"location":"essential-libraries/#variables_1","text":"","title":"Variables"},{"location":"essential-libraries/#consol","text":"Consol: byte absolute $d01f The variable returns the code of the pressed key/keys.","title":"Consol"},{"location":"essential-libraries/#textattr","text":"TextAttr: byte = 0 The variable stores the value that is added to each displayed sign, e.g. Textattr = $80 will cause the characters to be displayed in inverse.","title":"TextAttr"},{"location":"essential-libraries/#wherex","text":"WhereX: byte absolute $54; The variable stores the current horizontal position of the cursor.","title":"WhereX"},{"location":"essential-libraries/#wherey","text":"WhereY: byte absolute $55; The variable stores the current vertical position of the cursor.","title":"WhereY"},{"location":"essential-libraries/#procedures-and-functions_1","text":"ClrEol ClrScr CursorOff CursorOn Delay DelLine GotoXY InsLine Keypressed NoSound ReadKey Sound TextBackground TextColor","title":"Procedures and functions"},{"location":"essential-libraries/#clreol","text":"procedure ClrEol; The procedure cleans the line from the current cursor position to the right side of the screen edge. The cursor position does not change.","title":"ClrEol"},{"location":"essential-libraries/#clrscr","text":"procedure ClrScr; The procedure clears the editor screen, performs the CH_CLR sign code.","title":"ClrScr"},{"location":"essential-libraries/#cursoroff","text":"procedure CursorOff; The procedure turns off the cursor.","title":"CursorOff"},{"location":"essential-libraries/#cursoron","text":"procedure CursorOn; The procedure turns on the cursor.","title":"CursorOn"},{"location":"essential-libraries/#delay","text":"procedure Delay(MS: Word); The procedure awaits the given amount of miliseconds MS . Approximately Delay (1000) generates a delay of one second.","title":"Delay"},{"location":"essential-libraries/#delline","text":"procedure DelLine; The procedure deletes the line at the current cursor position, performs the CH_DELLINE character code.","title":"DelLine"},{"location":"essential-libraries/#gotoxy","text":"procedure GotoXY(x, y: byte); The procedure sets the new cursor position.","title":"GotoXY"},{"location":"essential-libraries/#insline","text":"procedure InsLine; The procedure inserts an empty line in the current cursor position, performs the CH_INSLIN sign code.","title":"InsLine"},{"location":"essential-libraries/#keypressed","text":"function Keypressed: Boolean; The function returns the TRUE when a keyboard key has been pressed, otherwise it returns FALSE .","title":"Keypressed"},{"location":"essential-libraries/#nosound","text":"procedure NoSound; The procedure silences the channels of both POKEY-i $D200 $D210) .","title":"NoSound"},{"location":"essential-libraries/#readkey","text":"function ReadKey: char; The function returns the code of the keyboard key.","title":"ReadKey"},{"location":"essential-libraries/#sound","text":"procedure Sound(Chan,Freq,Dist,Vol: byte); The procedure reproduces the sound on the POKEY-a CHAN (0..3, 4..7) , with a frequency of FREQ (0..255) , filters DIST (0..7) ,volume VOL (0..15) .","title":"Sound"},{"location":"essential-libraries/#textbackground","text":"procedure TextBackground(a: byte); The procedure sets a new color background color (works best with VBXE ).","title":"TextBackground"},{"location":"essential-libraries/#textcolor","text":"procedure TextColor(a: byte); The procedure sets a new text color (works best with VBXE ).","title":"TextColor"},{"location":"essential-libraries/#graph","text":"","title":"GRAPH"},{"location":"essential-libraries/#constants_2","text":"{ graphic drivers } D1bit = 11; D2bit = 12; D4bit = 13; D6bit = 14; // 64 colors Half-brite mode - Amiga D8bit = 15; D12bit = 16; // 4096 color modes HAM mode - Amiga m640x480 = 8 + 16; { error codes } grOK = 0; grNoInitGraph = -1; grNotDetected = -2; grFileNotFound = -3; grInvalidDriver = -4; grNoLoadMem = -5; grNoScanMem = -6; grNoFloodMem = -7; grFontNotFound = -8; grNoFontMem = -9; grInvalidMode = -10; grError = -11; grIOerror = -12; grInvalidFont = -13; grInvalidFontNum = -14; grInvalidVersion = -18;","title":"Constants"},{"location":"essential-libraries/#variables_2","text":"","title":"Variables"},{"location":"essential-libraries/#graphresult","text":"GraphResult : byte","title":"GraphResult"},{"location":"essential-libraries/#procedures-and-functions_2","text":"Bar Bar3D Circle ClipLine Ellipse FillEllipse FillRect FloodFill GetColor GetMaxX GetMaxY GetPixel GetX GetY InitGraph Line LineTo MoveRel MoveTo PutPixel Rectangle SetBkColor SetClipRect SetColor SetColorMapEntry SetColorMapDimensions","title":"Procedures and functions"},{"location":"essential-libraries/#bar","text":"procedure Bar(x1, y1, x2, y2: Smallint); A rectangle, e.g. for bolts.","title":"Bar"},{"location":"essential-libraries/#bar3d","text":"procedure Bar3D(x1, y1, x2, y2: smallint; depth: word; top: boolean); Post for three-dimensional charts.","title":"Bar3D"},{"location":"essential-libraries/#circle","text":"procedure Circle(x0,y0,radius: word); Circle.","title":"Circle"},{"location":"essential-libraries/#clipline","text":"procedure ClipLine(x1, y1, x2, y2: smallint);","title":"ClipLine"},{"location":"essential-libraries/#ellipse","text":"procedure Ellipse(x0, y0, a, b: word); Ellipse.","title":"Ellipse"},{"location":"essential-libraries/#fillellipse","text":"procedure FillEllipse(x0, y0, a, b: word); Ellipse filled inside.","title":"FillEllipse"},{"location":"essential-libraries/#fillrect","text":"procedure FillRect(Rect: TRect); A rectangle filled inside.","title":"FillRect"},{"location":"essential-libraries/#floodfill","text":"procedure FloodFill(x, y: smallint; color: byte); Filling the closed area of the screen.","title":"FloodFill"},{"location":"essential-libraries/#getcolor","text":"function GetColor: byte; assembler; Specify the current drawing color.","title":"GetColor"},{"location":"essential-libraries/#getmaxx","text":"function GetMaxX: word; Fetch the highest X coordinate value on the screen.","title":"GetMaxX"},{"location":"essential-libraries/#getmaxy","text":"function GetMaxY: word; Fetch the highest Y coordinate value on the screen.","title":"GetMaxY"},{"location":"essential-libraries/#getpixel","text":"function GetPixel(x,y: smallint): byte; Fetch the color of a given point on the screen.","title":"GetPixel"},{"location":"essential-libraries/#getx","text":"function GetX: smallint; Get the current X coordinate of the graphic cursor.","title":"GetX"},{"location":"essential-libraries/#gety","text":"function GetY: smallint; Get the current Y coordinate of the graphic cursor.","title":"GetY"},{"location":"essential-libraries/#initgraph","text":"procedure InitGraph(mode: byte); procedure InitGraph(driver, mode: byte; pth: TString); Initiate graphic mode.","title":"InitGraph"},{"location":"essential-libraries/#line","text":"procedure Line(x0, y0, x1, y1: smallint); A straight line.","title":"Line"},{"location":"essential-libraries/#lineto","text":"procedure LineTo(x, y: smallint); The line from the current position of the cursor to the indicated point.","title":"LineTo"},{"location":"essential-libraries/#moverel","text":"procedure MoveRel(Dx, Dy: smallint); Move the graphic cursor by a relative distance.","title":"MoveRel"},{"location":"essential-libraries/#moveto","text":"procedure MoveTo(x, y: smallint); Move the graphic cursor to the indicated point.","title":"MoveTo"},{"location":"essential-libraries/#putpixel","text":"procedure PutPixel(x,y: smallint); procedure PutPixel(x,y: smallint; color: byte); Light the point on the screen.","title":"PutPixel"},{"location":"essential-libraries/#rectangle","text":"procedure Rectangle(x1, y1, x2, y2: smallint); procedure Rectangle(Rect: TRect); Rectangle.","title":"Rectangle"},{"location":"essential-libraries/#setbkcolor","text":"procedure SetBkColor(color: byte); Set the background color.","title":"SetBkColor"},{"location":"essential-libraries/#setcliprect","text":"procedure SetClipRect(x0,y0,x1,y1: smallint); procedure SetClipRect(Rect: TRect);","title":"SetClipRect"},{"location":"essential-libraries/#setcolor","text":"procedure SetColor(color: byte); Set the pen color.","title":"SetColor"},{"location":"essential-libraries/#setcolormapentry","text":"procedure SetColorMapEntry; procedure SetColorMapEntry(a,b,c: byte);","title":"SetColorMapEntry"},{"location":"essential-libraries/#setcolormapdimensions","text":"procedure SetColorMapDimensions(w,h: byte);","title":"SetColorMapDimensions"},{"location":"essential-libraries/#sysutils","text":"","title":"SYSUTILS"},{"location":"essential-libraries/#constants_3","text":"faReadOnly = $01; faHidden = $02; faSysFile = $04; faVolumeID = $08; faDirectory = $10; faArchive = $20; faAnyFile = $3f;","title":"Constants"},{"location":"essential-libraries/#types_1","text":"","title":"Types"},{"location":"essential-libraries/#tsearchrec","text":"TSearchRec = record Attr: Byte; Name: TString; FindHandle: Pointer; end;","title":"TSearchRec"},{"location":"essential-libraries/#procedures-and-functions_3","text":"AnsiUpperCase Beep Click DeleteFile ExtractFileExt FileExists FindFirst FindNext FindClose GetTickCount IntToHex IntToStr RenameFile StrToFloat StrToInt","title":"Procedures and functions"},{"location":"essential-libraries/#ansiuppercase","text":"function AnsiUpperCase(const a: string): string; The function converts the characters from the a string.","title":"AnsiUpperCase"},{"location":"essential-libraries/#beep","text":"procedure Beep; Beep signal (Buzzer).","title":"Beep"},{"location":"essential-libraries/#click","text":"procedure Click; Keyboard signal.","title":"Click"},{"location":"essential-libraries/#deletefile_1","text":"function DeleteFile(var FileName: TString): Boolean; The function will delete the file specified in the FileName parameter, returns True when the operation was successful.","title":"DeleteFile"},{"location":"essential-libraries/#extractfileext","text":"function ExtractFileExt(const FileName: string): TString; Based on the file name or full path to the file specified in the FileName parameter, the function returns the extension (preceded by a dot - e.g. .txt ).","title":"ExtractFileExt"},{"location":"essential-libraries/#fileexists","text":"function FileExists(const FileName: string): Boolean; The function checks that the file specified in the FileName parameter exists or not.","title":"FileExists"},{"location":"essential-libraries/#findfirst","text":"function FindFirst(const FileMask: TString; Attributes: Byte; var SearchResult: TSearchRec): byte; The function searches for files matching the FileMask pattern and with attributes specified in Attributes . If files that match the template were found, the first of them is returned in the variable SerchResult .","title":"FindFirst"},{"location":"essential-libraries/#findnext","text":"function FindNext(var f: TSearchRec): byte; The function goes to the next record found earlier with the help of FindFirst . The parameter must be provided with a record that was previously used in the FindFirst function.","title":"FindNext"},{"location":"essential-libraries/#findclose","text":"procedure FindClose(var f: TSearchRec); The procedure releases resources (memory) utilized by the FindFirst function. This procedure should be called each time after the search process is completed.","title":"FindClose"},{"location":"essential-libraries/#gettickcount","text":"function GetTickCount: cardinal; GetTickCount returns the 24-bit time counter (PEEK(RTCLOK+2) + PEEK(RTCLOK+1)*256 + PEEK(RTCLOK)*65536) . This is useful for measuring time.","title":"GetTickCount"},{"location":"essential-libraries/#inttohex","text":"function IntToHex(Value: cardinal; Digits: byte): TString; The function converts the numerical value to its hexadecimal string equivalent.","title":"IntToHex"},{"location":"essential-libraries/#inttostr","text":"function IntToStr(a: integer): ^char; The function is used to convert the whole number given in the parameter to string format.","title":"IntToStr"},{"location":"essential-libraries/#renamefile_1","text":"function RenameFile(var OldName,NewName: TString): Boolean; The function tries to change the file name specified in the OldName parameter to NewName . If the operation is succeeded, the function will return the value of True otherwise False . It may happen that the function will not be able to change the name (e.g. when the application has no right to it) - then the function will return False .","title":"RenameFile"},{"location":"essential-libraries/#strtofloat","text":"function StrToFloat(var s: TString): real; The function converts the string to the Real floating point form.","title":"StrToFloat"},{"location":"essential-libraries/#strtoint","text":"function StrToInt(const S: char): byte; function StrToInt (const S: TString): integer; The function is used to convert the text saved in the S variable to an integer - if possible.","title":"StrToInt"},{"location":"essential-libraries/#vbxe","text":"The memory map for VBXE is defined in the SYSTEM module. VBXE_XDLADR = $0000; // XDLIST VBXE_MAPADR = $1000; // COLOR MAP ADDRESS VBXE_BCBADR = $0100; // BLITTER LIST ADDRESS VBXE_OVRADR = $5000; // OVERLAY ADDRESS VBXE_WINDOW = $B000; // 4K WINDOW $B000..$BFFF","title":"VBXE"},{"location":"essential-libraries/#constants_4","text":"LoRes = 1; // 160x240x256c MedRes = 2; // 320x240x256c HiRes = 3; // 640x240x16c","title":"Constants"},{"location":"essential-libraries/#types_2","text":"","title":"Types"},{"location":"essential-libraries/#tuint24","text":"record byte0: byte; byte1: byte; byte2: byte; end; 24-bit type used to define memory addresses VBXE .","title":"TUInt24"},{"location":"essential-libraries/#txdl","text":"record xdlc_: word; rptl_: byte; xdlc: word; rptl: byte; ov_adr: TUInt24; ov_step: word; mp_adr: TUInt24; mp_step: word; mp_hscrol: byte; mp_vscrol: byte; mp_width: byte; mp_height: byte; ov_width: byte; ov_prior: byte; end; Type TXDL used by the procedures GetXDL and SetXDL . It allows you to modify the program for VBXE used by Mad-Pascal .","title":"TXDL"},{"location":"essential-libraries/#tbcb","text":"record src_adr: TUInt24; src_step_y: smallint; src_step_x: shortint; dst_adr: TUInt24; dst_step_y: smallint; dst_step_x: shortint; blt_width: word; blt_height: byte; blt_and_mask: byte; blt_xor_mask: byte; blt_collision_mask: byte; blt_zoom: byte; pattern_feature: byte; blt_control: byte; end; Type TBCB (21 bytes), Blitter Code Block . Definition of the Blitter block type Blitter VBXE .","title":"TBCB"},{"location":"essential-libraries/#tvbxememorystream","text":"Object Position: cardinal; Size: cardinal; // 0..Size-1 procedure Create; procedure Clear; procedure SetBank; procedure ReadBuffer(var Buffer; Count: word); procedure WriteBuffer(var Buffer; Count: word); function ReadByte: Byte; function ReadWord: Word; function ReadDWord: Cardinal; procedure WriteByte(b: Byte); procedure WriteWord(w: Word); procedure WriteDWord(d: Cardinal); end; The TVBXEMemoryStream object allows for linear access to memory VBXE .","title":"TVBXEMemoryStream"},{"location":"essential-libraries/#procedures-and-functions_4","text":"BlitterBusy ColorMapOff ColorMapOn DstBCB ExtractFileExt GetXDL IniBCB OverlayOff RunBCB SetHorizontalRes VBXEMemoryBank SetXDL SrcBCB VBXEControl VBXEOff","title":"Procedures and functions"},{"location":"essential-libraries/#blitterbusy","text":"function BlitterBusy: Boolean; assembler; The function returns True if Blitter VBXE is occupied by performing a Blitter program.","title":"BlitterBusy"},{"location":"essential-libraries/#colormapoff","text":"procedure ColorMapOff; assembler; Turning off the color map in the XDLIST for VBXE .","title":"ColorMapOff"},{"location":"essential-libraries/#colormapon","text":"procedure ColorMapOn; assembler; Turning on the color map in the XDLIST for VBXE .","title":"ColorMapOn"},{"location":"essential-libraries/#dstbcb","text":"procedure DstBCB(var a: TBCB; dst: cardinal); The procedure amending the target address dst in the Blitter program a .","title":"DstBCB"},{"location":"essential-libraries/#getxdl","text":"procedure GetXDL(var a: txdl); register; assembler; The procedure prescribes to the variable A program XDLIST from the address VBXE_XDLADR in memory VBXE .","title":"GetXDL"},{"location":"essential-libraries/#inibcb","text":"procedure IniBCB(var a: TBCB; src,dst: cardinal; w0, w1: smallint; w: word; h: byte; ctrl: byte); The procedure allows you to initiate memory for the Blitter program at A . Additional parameters specify the address from which the SRC data will be copied, the target address of the copied data DST , width of W0 , target W1 target window, size of the result window, its width W , height H , and to specify the final parameters of the Blitter block CTRL (Bit 3 CTRL is set up to the Blitter reading of the next program and its implementation).","title":"IniBCB"},{"location":"essential-libraries/#overlayoff","text":"procedure OverlayOff; assembler; Disabling overlay mode in the XDLIST .","title":"OverlayOff"},{"location":"essential-libraries/#runbcb","text":"procedure RunBCB(var a: TBCB); assembler; Blitter starting VBXE based on the A program.","title":"RunBCB"},{"location":"essential-libraries/#sethorizontalres","text":"procedure SetHorizontalRes(a: byte); assembler; procedure SetHRes(a: byte); assembler; Establishment of overlay mode in the XDLIST program.","title":"SetHorizontalRes"},{"location":"essential-libraries/#vbxememorybank","text":"procedure VBXEMemoryBank(b: byte); assembler; Turning on 4K Bank VBXE in the memory window of the Atari 8-Bit $B000..$BCFF .","title":"VBXEMemoryBank"},{"location":"essential-libraries/#setxdl","text":"procedure SetXDL(var a: txdl); register; assembler; The procedure rewrites the A program to VBXE_XDLADR in memory VBXE .","title":"SetXDL"},{"location":"essential-libraries/#srcbcb","text":"procedure SrcBCB(var a: TBCB; src: cardinal); Procedure amending the source address SRC_ADR in the Blitter program A .","title":"SrcBCB"},{"location":"essential-libraries/#vbxecontrol","text":"procedure VBXEControl(a: byte); assembler; The procedure sets the value of FX_VIDEO_CONTROL .","title":"VBXEControl"},{"location":"essential-libraries/#vbxeoff","text":"procedure VBXEOff Disable, reset VBXE .","title":"VBXEOff"},{"location":"essential-libraries/#math","text":"","title":"MATH"},{"location":"essential-libraries/#procedures-and-functions_5","text":"ArcCos ArcSin ArcTan2 Ceil CycleToRad DegNormalize DegToGrad DegToRad DivMod EnsureRange Floor FMod GradToDeg GradToRad InRange IsNan Log2 Log10 LogN Max Min Power RadToCycle RadToDeg RadToGrad RandG RandomRange RandomRangeF Tan","title":"Procedures and functions"},{"location":"essential-libraries/#arccos","text":"function ArcCos(x: real): real; Arccos is the opposite function for the COS function. The value of the parameter X must belong to the interval of both sides of the range <-1; 1> . The value returned by the function is the angle from <0; ?> expressed in the radians.","title":"ArcCos"},{"location":"essential-libraries/#arcsin","text":"function ArcSin(x: real): real; The function is used to calculate the mathematical function of the Arcus Sinus with the number X . This is the opposite function to the sine function, i.e. sin(arcsin(x)) = x .","title":"ArcSin"},{"location":"essential-libraries/#arctan2","text":"function ArcTan2(y, x: real) : real; The function calculates Arcus Tangens (the opposite of Tangens) from the number Y/X and returns the value in radians.","title":"ArcTan2"},{"location":"essential-libraries/#ceil","text":"function Ceil(a: real): smallint; The function returns the smallest integer larger than or equal to the one given in the parameter.","title":"Ceil"},{"location":"essential-libraries/#cycletorad","text":"function CycleToRad(cycle : real) : real; The function converts the value of the angle expressed in cycles (revolutions) into an angle expressed in radians.","title":"CycleToRad"},{"location":"essential-libraries/#degnormalize","text":"function DegNormalize(deg : real) : real;","title":"DegNormalize"},{"location":"essential-libraries/#degtograd","text":"function DegToGrad(deg : real) : real; The function converts the value of the angle expressed in the degree of angle expressed in gradians.","title":"DegToGrad"},{"location":"essential-libraries/#degtorad","text":"function DegToRad(deg : real) : real; The function converts the value of the angle expressed in the degree of angle expressed in the arc, i.e. radians.","title":"DegToRad"},{"location":"essential-libraries/#divmod","text":"procedure DivMod(Dividend: integer; Divisor: Word; var r, Remainder: Word); procedure DivMod(Dividend: integer; Divisor: Word; var r, Remainder: smallint);","title":"DivMod"},{"location":"essential-libraries/#ensurerange","text":"function EnsureRange(const AValue, AMin, AMax: byte): Integer; function EnsureRange(const AValue, AMin, AMax: Integer): Integer;","title":"EnsureRange"},{"location":"essential-libraries/#floor","text":"function Floor(a: real): smallint; The function returns the nearest integers less or equal to the one given in the parameter.","title":"Floor"},{"location":"essential-libraries/#fmod","text":"function FMod(a, b: real): real; The function returns the rest of the division of two real numbers.","title":"FMod"},{"location":"essential-libraries/#gradtodeg","text":"function GradToDeg(grad : real) : real; The function converts the value of the angle expressed in gradians into the angle expressed in the degrees.","title":"GradToDeg"},{"location":"essential-libraries/#gradtorad","text":"function GradToRad(grad : real) : real; The GradToRad function converts the value of the angle expressed in gradians into the angle expressed in radians.","title":"GradToRad"},{"location":"essential-libraries/#inrange","text":"function InRange(const AValue, AMin, AMax: byte): Boolean; function InRange(const AValue, AMin, AMax: Integer): Boolean;","title":"InRange"},{"location":"essential-libraries/#isnan","text":"function IsNan(const d : Single): Boolean; The function checks whether the value of the parameter D is a proper number.","title":"IsNan"},{"location":"essential-libraries/#log2","text":"function log2(x : single): single; The function returns the logarithm value at base 2 for the real parameter X >0.","title":"Log2"},{"location":"essential-libraries/#log10","text":"function log10(x : single): single; The function returns the value of the decimal logarithm (logarithm at base 10) for the real parameter X >0.","title":"Log10"},{"location":"essential-libraries/#logn","text":"function logN(n,x : single): single; The function returns the logarithm value at the base N >0 for the real parameter X >0.","title":"LogN"},{"location":"essential-libraries/#max","text":"function Max(a, b: real): real; function Max(a, b: integer): integer; The overloaded function compares the values of two parameters: A and B , and returns the one that is larger.","title":"Max"},{"location":"essential-libraries/#min","text":"function Min(a, b: real): real; function Min(a, b: integer): integer; The overloaded function compares the values of two parameters A and B , and returns the value of the smaller one.","title":"Min"},{"location":"essential-libraries/#power","text":"function Power(base : real; const exponent : shortint): real; power(base : integer; const exponent : shortint): integer; The function increases the number to any power N, power can be a fraction.","title":"Power"},{"location":"essential-libraries/#radtocycle","text":"function RadToCycle(rad : real) : real; The function converts the value of the angle expressed in radians into an angle expressed in cycles (revolutions).","title":"RadToCycle"},{"location":"essential-libraries/#radtodeg","text":"function RadToDeg(rad : real) : real; The function converts the value of the angle expressed in radians into an angle expressed in degrees (DEG).","title":"RadToDeg"},{"location":"essential-libraries/#radtograd","text":"function RadToGrad(rad : real) : real; The function converts the value of the angle expressed in radians into an angle expressed in gradians.","title":"RadToGrad"},{"location":"essential-libraries/#randg","text":"function RandG(mean, StdDev : single) : single; RandG is represented by a pseudo-number generator with the distribution Gaussa around the average mean . The StdDev parameter is the standard deviation of the generated numbers from the average value of mean .","title":"RandG"},{"location":"essential-libraries/#randomrange","text":"function RandomRange(const aFrom, aTo: smallint): smallint; The function returns a random number from the AFrom - ATo range, including the value of ATo .","title":"RandomRange"},{"location":"essential-libraries/#randomrangef","text":"function RandomRangeF(const min, max: single): single;","title":"RandomRangeF"},{"location":"essential-libraries/#tan","text":"function Tan(x: Real): Real; The function returns the value of the angle tangent given in the X parameter.","title":"Tan"},{"location":"examples/","text":"Scripts Linux mp-build-a8 #!/bin/bash mp=\"$HOME/Programs/MadPascal/mp\" mads=\"$HOME/Programs/mads/mads\" base=\"$HOME/Programs/MadPascal/base\" if [ -z \"$1\" ]; then echo -e \"\\nPlease call '$0 <argument>' to run this command!\\n\" exit 1 fi name=${1::-4} $mp $name.pas -o if [ -f $name.a65 ]; then [ ! -d \"output\" ] && mkdir output mv $name.a65 output/ $mads output/$name.a65 -x -i:$base -o:output/$name.xex else exit 1 fi if [ ! -z \"$2\" ]; then atari800 output/$name.xex fi mp-build-a8 main.pas r mp-build-c64 #!/bin/bash mp=\"$HOME/Programs/MadPascal/mp\" mads=\"$HOME/Programs/mads/mads\" base=\"$HOME/Programs/MadPascal/base\" if [ -z \"$1\" ]; then echo -e \"\\nPlease call '$0 <argument>' to run this command!\\n\" exit 1 fi name=${1::-4} $mp $name.pas -t c64 -z 10 -o if [ -f $name.a65 ]; then [ ! -d \"output\" ] && mkdir output mv $name.a65 output/ $mads output/$name.a65 -x -i:$base -o:output/$name.prg else exit 1 fi if [ ! -z \"$2\" ]; then x64 output/$name.prg fi mp-build-c64 main.pas r Atari 8-bit Hello World program HelloWorld; uses crt; begin writeln('Hello World'); readkey; end. C64 Test // https://bitbucket.org/paul_nicholls/pas6502/src/master/projects/pas6502_test.dpr program Test; const cScreen0 = 1024; cColor = $d800; var border : Byte absolute $D020; background : Byte absolute $D021; screen0 : array[0..1000-1] of Byte absolute cScreen0; color0 : array[0..1000-1] of Byte absolute cColor; i : Integer; begin i := 0; while i < 1000 do begin // fill screen with all screen codes (wrapping around). screen0[i] := i; // fill color RAM with all colors color0[i] := i; Inc(i); end; end.","title":"Examples"},{"location":"examples/#_1","text":"","title":""},{"location":"examples/#scripts","text":"","title":"Scripts"},{"location":"examples/#linux","text":"","title":"Linux"},{"location":"examples/#mp-build-a8","text":"#!/bin/bash mp=\"$HOME/Programs/MadPascal/mp\" mads=\"$HOME/Programs/mads/mads\" base=\"$HOME/Programs/MadPascal/base\" if [ -z \"$1\" ]; then echo -e \"\\nPlease call '$0 <argument>' to run this command!\\n\" exit 1 fi name=${1::-4} $mp $name.pas -o if [ -f $name.a65 ]; then [ ! -d \"output\" ] && mkdir output mv $name.a65 output/ $mads output/$name.a65 -x -i:$base -o:output/$name.xex else exit 1 fi if [ ! -z \"$2\" ]; then atari800 output/$name.xex fi mp-build-a8 main.pas r","title":"mp-build-a8"},{"location":"examples/#mp-build-c64","text":"#!/bin/bash mp=\"$HOME/Programs/MadPascal/mp\" mads=\"$HOME/Programs/mads/mads\" base=\"$HOME/Programs/MadPascal/base\" if [ -z \"$1\" ]; then echo -e \"\\nPlease call '$0 <argument>' to run this command!\\n\" exit 1 fi name=${1::-4} $mp $name.pas -t c64 -z 10 -o if [ -f $name.a65 ]; then [ ! -d \"output\" ] && mkdir output mv $name.a65 output/ $mads output/$name.a65 -x -i:$base -o:output/$name.prg else exit 1 fi if [ ! -z \"$2\" ]; then x64 output/$name.prg fi mp-build-c64 main.pas r","title":"mp-build-c64"},{"location":"examples/#atari-8-bit","text":"","title":"Atari 8-bit"},{"location":"examples/#hello-world","text":"program HelloWorld; uses crt; begin writeln('Hello World'); readkey; end.","title":"Hello World"},{"location":"examples/#c64","text":"","title":"C64"},{"location":"examples/#test","text":"// https://bitbucket.org/paul_nicholls/pas6502/src/master/projects/pas6502_test.dpr program Test; const cScreen0 = 1024; cColor = $d800; var border : Byte absolute $D020; background : Byte absolute $D021; screen0 : array[0..1000-1] of Byte absolute cScreen0; color0 : array[0..1000-1] of Byte absolute cColor; i : Integer; begin i := 0; while i < 1000 do begin // fill screen with all screen codes (wrapping around). screen0[i] := i; // fill color RAM with all colors color0[i] := i; Inc(i); end; end.","title":"Test"},{"location":"files/","text":"File operations FILE var f: file; TEXT var f: text; // TEXT g: textfile; // TEXTFILE alternatively ASSIGN Example of channel opening for S: device (screen) to output characters in GRAPHICS 1 , GRAPHICS 2 mode var scr: text; s: string = 'color COLOR ' + #155 + 'COLOR '* + 'color '*; begin assign(scr, 'S:'); // before InitGraph rewrite(scr); // before InitGraph InitGraph(2); // Graphics 2 GotoXY(1,6); write(scr, s); close(scr); end. RESET var t: text; reset(t); // for reading a text file, no additional parameter with record size var f: file; reset(t, 1); // for reading a binary file (record = 1) If no record length is specified for the binary file FILE , the default value =128 will be taken REWRITE var t: text; rewrite(t); // for writing a text file, no additional parameter with record size var f: file; rewrite(f, 1); // for writing a binary file (record = 1) If no record length is specified for the binary file FILE , the default value =128 will be taken APPEND var t: text; begin assign(t, 'D:TEXT.TXT'); append(t); writeln(t, 'ATARI'); writeln(t, 'C64'); write(t, 'Amstrad'); close(t); BLOCKREAD var f: file; pnt: pointer; begin pnt:=pointer(dpeek(88)); assign(f, 'D:FILENAME'); reset(f, 1); blockread(f, pnt^, 8); close(f); end. var f: file; buf: array [0..0] of byte; begin buf:=pointer(dpeek(88)); assign(f, 'D:FILENAME'); reset(f, 1); blockread(f, buf, 8); close(f); end. BLOCKWRITE var f: file; buf: array [0..0] of byte ABSOLUTE $bc40; begin assign(f, 'D:FILENAME'); rewrite(f, 1); blockwrite(f, buf, 40*24); close(f); end.","title":"File operations"},{"location":"files/#file-operations","text":"","title":"File operations"},{"location":"files/#file","text":"var f: file;","title":"FILE"},{"location":"files/#text","text":"var f: text; // TEXT g: textfile; // TEXTFILE alternatively","title":"TEXT"},{"location":"files/#assign","text":"Example of channel opening for S: device (screen) to output characters in GRAPHICS 1 , GRAPHICS 2 mode var scr: text; s: string = 'color COLOR ' + #155 + 'COLOR '* + 'color '*; begin assign(scr, 'S:'); // before InitGraph rewrite(scr); // before InitGraph InitGraph(2); // Graphics 2 GotoXY(1,6); write(scr, s); close(scr); end.","title":"ASSIGN"},{"location":"files/#reset","text":"var t: text; reset(t); // for reading a text file, no additional parameter with record size var f: file; reset(t, 1); // for reading a binary file (record = 1) If no record length is specified for the binary file FILE , the default value =128 will be taken","title":"RESET"},{"location":"files/#rewrite","text":"var t: text; rewrite(t); // for writing a text file, no additional parameter with record size var f: file; rewrite(f, 1); // for writing a binary file (record = 1) If no record length is specified for the binary file FILE , the default value =128 will be taken","title":"REWRITE"},{"location":"files/#append","text":"var t: text; begin assign(t, 'D:TEXT.TXT'); append(t); writeln(t, 'ATARI'); writeln(t, 'C64'); write(t, 'Amstrad'); close(t);","title":"APPEND"},{"location":"files/#blockread","text":"var f: file; pnt: pointer; begin pnt:=pointer(dpeek(88)); assign(f, 'D:FILENAME'); reset(f, 1); blockread(f, pnt^, 8); close(f); end. var f: file; buf: array [0..0] of byte; begin buf:=pointer(dpeek(88)); assign(f, 'D:FILENAME'); reset(f, 1); blockread(f, buf, 8); close(f); end.","title":"BLOCKREAD"},{"location":"files/#blockwrite","text":"var f: file; buf: array [0..0] of byte ABSOLUTE $bc40; begin assign(f, 'D:FILENAME'); rewrite(f, 1); blockwrite(f, buf, 40*24); close(f); end.","title":"BLOCKWRITE"},{"location":"instructions/","text":"Conditional case of else Currently, Mad Pascal only accepts types with a length of 1 byte for the CASE variable: SHORTINT BYTE CHAR BOOLEAN . case a of // for a variable A of type CHAR 'A'..'Z': begin end; '0'..'9': begin end; '+','*': begin end; end; if then else IF conditional instructions can be nested. This is used for more complex conditions. Iterative for to downto do FOR variable := { initial value } TO { final value } DO { instructions to execute } FOR variable := { final value } DOWNTO { initial value } DO { instructions to execute } This instruction is used to organize calculations which are performed a predetermined number of times. The control variable shall be an identifier of the ordinal type and both expressions shall be consistent in terms of assignment with the control variable type. During the TO loop execution, the control variable is assigned the subsequent value in the given type, in the DOWNTO loop, the preceding one. It is prohibited to \"manually\" change the value of a control variable. In case of such an attempt, Mad-Pascal signal an error Illegal assignment to for-loop variable . The compiler makes sure that there is no endless loop so that you can use such a loop without a doubt: for i:=0 to 255 do writeln(i); // for a variable I of type BYTE for in do FOR variable IN array DO { instructions to execute } FOR variable IN 'string literal' DO { instructions to execute } The FOR IN DO construct allows for faster reading of array elements or text constants. var days : array [0..6] of string = ('poniedzialek', 'wtorek', 'sroda' ,'czwartek', 'piatek', 'sobota', 'niedziela'); a: string; begin for a in days do writeln(a); while do while { condition } do { instructions to execute } This construct is used to organize calculations that will be performed as long as the expression after the word WHILE is true. Such a loop may not be executed even once. while BlitterBusy do; // waiting for the VBXE blitter to finish Limitations for WHILE instructions: while i<=255 do inc(i); // endless loop if I is of type BYTE repeat until repeat { instructions to execute } until { termination condition } This statement cyclically executes other statements between REPEAT and UNTIL until the expression after UNTIL takes the value of TRUE . The effect of the REPEAT loop is very similar to that of the WHILE loop. This loop can also be performed a huge number of times. The only difference is that in the REPEAT loop the end condition is only checked after the instruction is executed. This means that the REPEAT loop will always be done at least once. Only after this iteration will the program check if the loop can be terminated. In the case of the WHILE loop, the condition is checked immediately before it is executed, which may result in the loop never being executed. i:=0; repeat inc(i); until i=0; // the loop will repeat 256 times","title":"Instructions"},{"location":"instructions/#_1","text":"","title":""},{"location":"instructions/#conditional","text":"","title":"Conditional"},{"location":"instructions/#case-of-else","text":"Currently, Mad Pascal only accepts types with a length of 1 byte for the CASE variable: SHORTINT BYTE CHAR BOOLEAN . case a of // for a variable A of type CHAR 'A'..'Z': begin end; '0'..'9': begin end; '+','*': begin end; end;","title":"case of else"},{"location":"instructions/#if-then-else","text":"IF conditional instructions can be nested. This is used for more complex conditions.","title":"if then else"},{"location":"instructions/#iterative","text":"","title":"Iterative"},{"location":"instructions/#for-to-downto-do","text":"FOR variable := { initial value } TO { final value } DO { instructions to execute } FOR variable := { final value } DOWNTO { initial value } DO { instructions to execute } This instruction is used to organize calculations which are performed a predetermined number of times. The control variable shall be an identifier of the ordinal type and both expressions shall be consistent in terms of assignment with the control variable type. During the TO loop execution, the control variable is assigned the subsequent value in the given type, in the DOWNTO loop, the preceding one. It is prohibited to \"manually\" change the value of a control variable. In case of such an attempt, Mad-Pascal signal an error Illegal assignment to for-loop variable . The compiler makes sure that there is no endless loop so that you can use such a loop without a doubt: for i:=0 to 255 do writeln(i); // for a variable I of type BYTE","title":"for to downto do"},{"location":"instructions/#for-in-do","text":"FOR variable IN array DO { instructions to execute } FOR variable IN 'string literal' DO { instructions to execute } The FOR IN DO construct allows for faster reading of array elements or text constants. var days : array [0..6] of string = ('poniedzialek', 'wtorek', 'sroda' ,'czwartek', 'piatek', 'sobota', 'niedziela'); a: string; begin for a in days do writeln(a);","title":"for in do"},{"location":"instructions/#while-do","text":"while { condition } do { instructions to execute } This construct is used to organize calculations that will be performed as long as the expression after the word WHILE is true. Such a loop may not be executed even once. while BlitterBusy do; // waiting for the VBXE blitter to finish Limitations for WHILE instructions: while i<=255 do inc(i); // endless loop if I is of type BYTE","title":"while do"},{"location":"instructions/#repeat-until","text":"repeat { instructions to execute } until { termination condition } This statement cyclically executes other statements between REPEAT and UNTIL until the expression after UNTIL takes the value of TRUE . The effect of the REPEAT loop is very similar to that of the WHILE loop. This loop can also be performed a huge number of times. The only difference is that in the REPEAT loop the end condition is only checked after the instruction is executed. This means that the REPEAT loop will always be done at least once. Only after this iteration will the program check if the loop can be terminated. In the case of the WHILE loop, the condition is checked immediately before it is executed, which may result in the loop never being executed. i:=0; repeat inc(i); until i=0; // the loop will repeat 256 times","title":"repeat until"},{"location":"interrupts/","text":"VBL, DLI Two routines GetIntVec and SetIntVec are dedicated to handle VBL , DLI interrupts. The presence of OS is required for proper operation (disable ROM only by $DEFINE ROMOFF ) GetIntVec GetIntVec(iVBLI, pointer); // pobranie adresu programu obs\u0142ugi przerwa\u0144 VBLI ($0222) GetIntVec(iVBLD, pointer); // pobranie adresu programu obs\u0142ugi przerwa\u0144 VBLD ($0224) GetIntVec(iDLI, pointer); // pobranie adresu programu obs\u0142ugi przerwa\u0144 DLI ($0200) var oldVBL: pointer; begin GetIntVec(iVBL, oldVBL); end. SetIntVec SetIntVec(iVBLI, pointer); // ustanowienie adresu programu obs\u0142ugi przerwa\u0144 VBLI ($0222) SetIntVec(iVBLD, pointer); // ustanowienie adresu programu obs\u0142ugi przerwa\u0144 VBLD ($0224) SetIntVec(iDLI, pointer); // ustanowienie adresu programu obs\u0142ugi przerwa\u0144 DLI ($0200) procedure newVBL; interrupt; assembler; asm jmp xitvbv end; begin SetIntVec(iVBL, @newVBL); end. The VBL interrupt is terminated by jumping to the XITVBV address ($E462) which will restore the value of the A X Y CPU6502 registers. If we have disabled ROM by {$define romoff} and are using routines placed in memory $C000..$FFFF we must take care to set PORTB properly. procedure newVBL; interrupt; assembler; asm dec portb jsr user_proc_c000_ffff inc portb jmp xitvbv end; ```delphi procedure newVBL; interrupt; assembler; asm jmp sysvbv end; begin SetIntVec(iVBLI, @newVBL); end. We terminate the VBLDI (VBL immediate) interrupt by jumping to the SYSVBV address ($E45F) which will continue handling the VBL interrupt. If we have disabled ROM by {$define romoff} and are using routines placed in memory $C000..$FFFF we must take care to set PORTB properly. procedure newVBL; interrupt; assembler; asm dec portb jsr user_proc_c000_ffff inc portb jmp sysvbv end; ## IRQ - TIMER1, TIMER2, TIMER4 Two routines `GetIntVec` and `SetIntVec` are dedicated to handle **IRQ** - **TIMER1**, **TIMER2**, **TIMER4** interrupts. The presence of OS is required for proper operation (disable ROM only by [$DEFINE ROMOFF](/composition/#romoff)) ### GetIntVec GetIntVec(iTIM1, pointer); // getting the address of the TIMER 1 interrupt handler ($0210) GetIntVec(iTIM2, pointer); // getting the address of the TIMER 2 interrupt handler ($0212) GetIntVec(iTIM4, pointer); // getting the address of the TIMER 4 interrupt handler ($0214) ```delphi var oldIRQ: pointer; begin GetIntVec(iTIM4, oldIRQ); end. SetIntVec SetIntVec(iTIM1, pointer); // establishing the address of the TIMER 1 interrupt handler ($0210) SetIntVec(iTIM2, pointer); // establishing the address of the TIMER 2 interrupt handler ($0212) SetIntVec(iTIM4, pointer); // establishing the address of the TIMER 4 interrupt handler ($0214) procedure irq; assembler; interrupt; asm pla end; begin SetIntVec(iTIM4, @irq, 0, 28); repeat until keypressed; SetIntVec(iTIM4, oldIRQ); end. When the system executes a jump to an interrupt service routine, it puts the contents of the accumulator on the stack beforehand; keep this in mind and end the interrupt service with PLA . Additional parameters are required to trigger a new IRQ interrupt, such as the choice of base clock clock_base = [0,1] and frequency rate = [6.255] . Values of rate less than 6 will cause the system to slow down severely, up to a possible suspension. SetIntVec(iTIM1, pointer, clock_base, rate); SetIntVec(iTIM2, pointer, clock_base, rate); SetIntVec(iTIM4, pointer, clock_base, rate);","title":"Interrupt handling"},{"location":"interrupts/#_1","text":"","title":""},{"location":"interrupts/#vbl-dli","text":"Two routines GetIntVec and SetIntVec are dedicated to handle VBL , DLI interrupts. The presence of OS is required for proper operation (disable ROM only by $DEFINE ROMOFF )","title":"VBL, DLI"},{"location":"interrupts/#getintvec","text":"GetIntVec(iVBLI, pointer); // pobranie adresu programu obs\u0142ugi przerwa\u0144 VBLI ($0222) GetIntVec(iVBLD, pointer); // pobranie adresu programu obs\u0142ugi przerwa\u0144 VBLD ($0224) GetIntVec(iDLI, pointer); // pobranie adresu programu obs\u0142ugi przerwa\u0144 DLI ($0200) var oldVBL: pointer; begin GetIntVec(iVBL, oldVBL); end.","title":"GetIntVec"},{"location":"interrupts/#setintvec","text":"SetIntVec(iVBLI, pointer); // ustanowienie adresu programu obs\u0142ugi przerwa\u0144 VBLI ($0222) SetIntVec(iVBLD, pointer); // ustanowienie adresu programu obs\u0142ugi przerwa\u0144 VBLD ($0224) SetIntVec(iDLI, pointer); // ustanowienie adresu programu obs\u0142ugi przerwa\u0144 DLI ($0200) procedure newVBL; interrupt; assembler; asm jmp xitvbv end; begin SetIntVec(iVBL, @newVBL); end. The VBL interrupt is terminated by jumping to the XITVBV address ($E462) which will restore the value of the A X Y CPU6502 registers. If we have disabled ROM by {$define romoff} and are using routines placed in memory $C000..$FFFF we must take care to set PORTB properly. procedure newVBL; interrupt; assembler; asm dec portb jsr user_proc_c000_ffff inc portb jmp xitvbv end; ```delphi procedure newVBL; interrupt; assembler; asm jmp sysvbv end; begin SetIntVec(iVBLI, @newVBL); end. We terminate the VBLDI (VBL immediate) interrupt by jumping to the SYSVBV address ($E45F) which will continue handling the VBL interrupt. If we have disabled ROM by {$define romoff} and are using routines placed in memory $C000..$FFFF we must take care to set PORTB properly. procedure newVBL; interrupt; assembler; asm dec portb jsr user_proc_c000_ffff inc portb jmp sysvbv end; ## IRQ - TIMER1, TIMER2, TIMER4 Two routines `GetIntVec` and `SetIntVec` are dedicated to handle **IRQ** - **TIMER1**, **TIMER2**, **TIMER4** interrupts. The presence of OS is required for proper operation (disable ROM only by [$DEFINE ROMOFF](/composition/#romoff)) ### GetIntVec GetIntVec(iTIM1, pointer); // getting the address of the TIMER 1 interrupt handler ($0210) GetIntVec(iTIM2, pointer); // getting the address of the TIMER 2 interrupt handler ($0212) GetIntVec(iTIM4, pointer); // getting the address of the TIMER 4 interrupt handler ($0214) ```delphi var oldIRQ: pointer; begin GetIntVec(iTIM4, oldIRQ); end.","title":"SetIntVec"},{"location":"interrupts/#setintvec_1","text":"SetIntVec(iTIM1, pointer); // establishing the address of the TIMER 1 interrupt handler ($0210) SetIntVec(iTIM2, pointer); // establishing the address of the TIMER 2 interrupt handler ($0212) SetIntVec(iTIM4, pointer); // establishing the address of the TIMER 4 interrupt handler ($0214) procedure irq; assembler; interrupt; asm pla end; begin SetIntVec(iTIM4, @irq, 0, 28); repeat until keypressed; SetIntVec(iTIM4, oldIRQ); end. When the system executes a jump to an interrupt service routine, it puts the contents of the accumulator on the stack beforehand; keep this in mind and end the interrupt service with PLA . Additional parameters are required to trigger a new IRQ interrupt, such as the choice of base clock clock_base = [0,1] and frequency rate = [6.255] . Values of rate less than 6 will cause the system to slow down severely, up to a possible suspension. SetIntVec(iTIM1, pointer, clock_base, rate); SetIntVec(iTIM2, pointer, clock_base, rate); SetIntVec(iTIM4, pointer, clock_base, rate);","title":"SetIntVec"},{"location":"introduction/","text":"Foreword Mad-Pascal (MP) is a 32-bit Turbo Pascal compiler for Atari 8-Bit and other MOS 6502 CPU -based computers. By design, it is compatible with the Free Pascal Compiler (FPC) (the -MDelphi switch should be active). This means the possibility of obtaining executable code for Atari 8-bit , Windows , and every other platform for which FPC exists. Mad-Pascal is not a port of FPC . It has been written based on SUB-Pascal (2009) and XD-Pascal (2010), the author of which is Vasiliy Tereshkov . Mad-Pascal uses 64KB of primary memory. The class TMemoryStream provides access to extended memory. A program that works on Atari 8-Bit might have problems on Windows and other platforms if, for example, the pointers have not been initialized with the address of a variable. Writing via an uninitialized pointer results in an attempt to write to the address 0x0 and causes a memory protection fault. The strengths of Mad-Pascal include the fast and convenient possibility of including inline assembly. A program using inline ASM only works on platforms with MOS 6502 CPU . Variable allocation is static. There is no dynamic memory management. Parameters are passed to functions by value, variable, or constant. The available features are: If Case For While Repeat statements Compound statements Label Goto statements Arithmetic and boolean operators Procedures and functions with up to 8 parameters. The returned value of a function is assigned to a predefined RESULT variable Static local variables Primitive data types, all types except the ShortReal / Real type, are compatible. Pointers are dereferenced as pointers to Word : Cardinal Word Byte Boolean String PChar Char Integer SmallInt ShortInt Pointer File Text ShortReal Real fixed-point Float Single Float16 One-dimensional and Two-dimensional arrays (with zero lower bound) of any primitive type. Arrays are treated as pointers to their origins (like in C) and can be passed to subroutines as parameters Predefined type string [N] , which is equivalent to array [0..N] of Char Type aliases. Records Objects Separate program modules Separate library modules Recursion Folder Structure In the folder Mad-Pascal , the following files and subfolders are required: MP\\ mp.exe base\\ atari\\ c4p\\ c64\\ common\\ neo\\ raw\\ runtime\\ rtl_default.asm rtl6502_a8.asm rtl6502_c4p.asm rtl6502_c64.asm rtl6502_neo.asm rtl6502_raw.asm blibs\\ dlibs\\ include\\ lib\\ src\\ targets\\ wblibs\\ Compiling To compile the sources of Mad-Pascal use the Free Pascal Compiler (FPC), which can be downloaded from freepascal.org . Launch the installer and choose the folder for the installation of FPC . It is crucial not to use the exclamation mark ! or other nonstandard characters in the folder name. If it fails to compile any file, it is probably the fault of a nonstandard pathname. The command line launching the compilation may look as follows (letter case in parameter names matters): fpc -Mdelphi -v -O3 mp.pas -Mdelphi allows for Delphi format file compilation -v shows all error and warning diagnostics -O3 performs code optimization Libraries LIB BLIBS WLIBS Links Free Pascal Reference Guide MadPascal AtariAge forum MadPascal Examples Atari 8-bit Pascal Compilers","title":"Introduction"},{"location":"introduction/#foreword","text":"Mad-Pascal (MP) is a 32-bit Turbo Pascal compiler for Atari 8-Bit and other MOS 6502 CPU -based computers. By design, it is compatible with the Free Pascal Compiler (FPC) (the -MDelphi switch should be active). This means the possibility of obtaining executable code for Atari 8-bit , Windows , and every other platform for which FPC exists. Mad-Pascal is not a port of FPC . It has been written based on SUB-Pascal (2009) and XD-Pascal (2010), the author of which is Vasiliy Tereshkov . Mad-Pascal uses 64KB of primary memory. The class TMemoryStream provides access to extended memory. A program that works on Atari 8-Bit might have problems on Windows and other platforms if, for example, the pointers have not been initialized with the address of a variable. Writing via an uninitialized pointer results in an attempt to write to the address 0x0 and causes a memory protection fault. The strengths of Mad-Pascal include the fast and convenient possibility of including inline assembly. A program using inline ASM only works on platforms with MOS 6502 CPU . Variable allocation is static. There is no dynamic memory management. Parameters are passed to functions by value, variable, or constant. The available features are: If Case For While Repeat statements Compound statements Label Goto statements Arithmetic and boolean operators Procedures and functions with up to 8 parameters. The returned value of a function is assigned to a predefined RESULT variable Static local variables Primitive data types, all types except the ShortReal / Real type, are compatible. Pointers are dereferenced as pointers to Word : Cardinal Word Byte Boolean String PChar Char Integer SmallInt ShortInt Pointer File Text ShortReal Real fixed-point Float Single Float16 One-dimensional and Two-dimensional arrays (with zero lower bound) of any primitive type. Arrays are treated as pointers to their origins (like in C) and can be passed to subroutines as parameters Predefined type string [N] , which is equivalent to array [0..N] of Char Type aliases. Records Objects Separate program modules Separate library modules Recursion","title":"Foreword"},{"location":"introduction/#folder-structure","text":"In the folder Mad-Pascal , the following files and subfolders are required: MP\\ mp.exe base\\ atari\\ c4p\\ c64\\ common\\ neo\\ raw\\ runtime\\ rtl_default.asm rtl6502_a8.asm rtl6502_c4p.asm rtl6502_c64.asm rtl6502_neo.asm rtl6502_raw.asm blibs\\ dlibs\\ include\\ lib\\ src\\ targets\\ wblibs\\","title":"Folder Structure"},{"location":"introduction/#compiling","text":"To compile the sources of Mad-Pascal use the Free Pascal Compiler (FPC), which can be downloaded from freepascal.org . Launch the installer and choose the folder for the installation of FPC . It is crucial not to use the exclamation mark ! or other nonstandard characters in the folder name. If it fails to compile any file, it is probably the fault of a nonstandard pathname. The command line launching the compilation may look as follows (letter case in parameter names matters): fpc -Mdelphi -v -O3 mp.pas -Mdelphi allows for Delphi format file compilation -v shows all error and warning diagnostics -O3 performs code optimization","title":"Compiling"},{"location":"introduction/#libraries","text":"LIB BLIBS WLIBS","title":"Libraries"},{"location":"introduction/#links","text":"Free Pascal Reference Guide MadPascal AtariAge forum MadPascal Examples Atari 8-bit Pascal Compilers","title":"Links"},{"location":"macros/","text":"Macros Mad-Pascal allows you to use macros, just like FPC , except that macros are always enabled. {$macro on} {$macro off} {$macro+} {$macro-} The {$macro on} directive is required by FPC , in Mad-Pascal it is retained for compatibility purposes only. Defining a macro {$define label := expression} {$define label(par0, par1 ... par7) := expression} For a definition to be recognized as a macro, the assignment symbol := must occur after the label name and any (par0..par7) parameter list. {$define new_proc := procedure test; begin writeln('ok'); end; } new_proc begin test; end. {$define sum_xi := x:=x+i; } begin sum_xi; end; {$define WIDTH := 80} {$define LEN := ( WIDTH + 10 )} var a: byte; begin a := len * 20; end. Macros with parameters are supported by Mad-Pascal but not by FPC , keep this in mind if you intend to test code on other hardware platforms. {$define SIGN_MASK := $8000} {$define SIGNED_INF_VALUE(x) := ((x and SIGN_MASK) or $7C00)} var a: byte = 11; begin writeln( SIGNED_INF_VALUE(a shl 15) ); end.","title":"Macros"},{"location":"macros/#_1","text":"","title":""},{"location":"macros/#macros","text":"Mad-Pascal allows you to use macros, just like FPC , except that macros are always enabled. {$macro on} {$macro off} {$macro+} {$macro-} The {$macro on} directive is required by FPC , in Mad-Pascal it is retained for compatibility purposes only.","title":"Macros"},{"location":"macros/#defining-a-macro","text":"{$define label := expression} {$define label(par0, par1 ... par7) := expression} For a definition to be recognized as a macro, the assignment symbol := must occur after the label name and any (par0..par7) parameter list. {$define new_proc := procedure test; begin writeln('ok'); end; } new_proc begin test; end. {$define sum_xi := x:=x+i; } begin sum_xi; end; {$define WIDTH := 80} {$define LEN := ( WIDTH + 10 )} var a: byte; begin a := len * 20; end. Macros with parameters are supported by Mad-Pascal but not by FPC , keep this in mind if you intend to test code on other hardware platforms. {$define SIGN_MASK := $8000} {$define SIGNED_INF_VALUE(x) := ((x and SIGN_MASK) or $7C00)} var a: byte = 11; begin writeln( SIGNED_INF_VALUE(a shl 15) ); end.","title":"Defining a macro"},{"location":"map/","text":"Memory map Atari 8-Bit The compiler uses the zero page in the range $0080 .. $00D7 When using additional memory, the bank code array for PORTB is placed from $0101 ... $0140 An additional 256 byte memory buffer used for string operations is located from $0400 ... $04FF STACKORIGIN STATICDATA RUNTIME LIBRARY UNIT INITIALIZATIONS MAIN PROGRAM .LOCAL MAIN (all procedures / functions) .LOCAL @DEFINES .LOCAL @RESOURCE DATAORIGIN PROGRAMSTACK","title":"Memory map"},{"location":"map/#_1","text":"","title":""},{"location":"map/#memory-map","text":"Atari 8-Bit The compiler uses the zero page in the range $0080 .. $00D7 When using additional memory, the bank code array for PORTB is placed from $0101 ... $0140 An additional 256 byte memory buffer used for string operations is located from $0400 ... $04FF STACKORIGIN STATICDATA RUNTIME LIBRARY UNIT INITIALIZATIONS MAIN PROGRAM .LOCAL MAIN (all procedures / functions) .LOCAL @DEFINES .LOCAL @RESOURCE DATAORIGIN PROGRAMSTACK","title":"Memory map"},{"location":"procedures-functions/","text":"Procedure Mad-Pascal allows up to 8 parameters to be transferred to the procedure. There are three ways to pass parameters - by value, constant CONST and variable VAR . It is possible to use the OVERLOAD modifier to overload procedures. Available procedure modifiers: OVERLOAD ASSEMBLER FORWARD REGISTER INTERRUPT PASCAL . Procedure parameters are read and valued from right to left tests\\tests-medium\\function_valuation_of_arguments.pas It is possible to recurse procedures, provided that the procedure parameters will be passed by value and will be of a simple - ordinal type. The record or pointer type will not be properly allocated in memory. Function Mad-Pascal allows you to transfer up to 8 parameters to the function. There are three ways to pass parameters - by value, constant CONST and variable VAR . We return the result of the function by assigning it to the function name or using the automatically declared RESULT variable, e.g: function add(a,b: word): cardinal; begin Result := a+b; end; function mul(a,b: word): cardinal; begin mul := a*b; end; Available function modifiers: OVERLOAD ASSEMBLER FORWARD REGISTER INTERRUPT PASCAL INTERRUPT not recommended for functions. Function parameters are read and valued from right to left tests\\tests-medium\\function_valuation_of_arguments.pas It is possible to recurse functions, provided that the function parameters will be passed by value and will be of a simple - ordinal type. The record or pointer type will not be properly allocated in memory. Modifiers assembler The procedures/functions marked by ASSEMBLER can only consist of an ASM block. The compiler does not analyze the syntax of such blocks, treats them as a comment, possible errors are caught only during the assembly. WARNING It is required to maintain the state of the X CPU6502 register, which is used to operate the Mad-Pascal software stack. procedure color(a: byte); assembler; asm { mva a 712 }; end; overload Overloaded procedures/functions are recognized by the parameter list. procedure sum(var i: integer; a,b: integer); overload; begin i := a+b; end; procedure sum(var i: integer; a,b,c: integer); overload; begin i := a+b+c; end; function fsum(a,b: word): cardinal; assembler; overload; asm { adw a b result }; end; function fsum(a,b: real): real; overload; begin Result := a+b; end; forward If you want the procedure/function to be declared after its first call, use the FORWARD modifier. procedure name [(formal-parameter-list)]; forward; ... ... ... procedure name; begin end; register Using REGISTER modifier causes the first three formal parameters of the procedure/function to be placed on the zero page, in 32-bit general-purpose registers EDX , ECX , EAX respectively. procedure name (a,b,c: cardinal); register; // a = edx // b = ecx // c = eax interrupt Procedures/Functions marked by INTERRUPT end with RTI instruction (instead of standard RTS ). Regardless of whether such procedure/function is called in the program, the compiler always generates code for it. It is recommended to use the ASM block for such procedure/function , otherwise the Mad Pascal software stack will be destroyed, which may lead to unstable program operation, including computer crashes. At the beginning of the procedure/function marked by INTERRUPT , the programmer must take care to keep the CPU registers A X Y , at the output to restore such registers, the compiler only inserts the final RTI command. procedure dli; interrupt; asm { pha lda #$c8 sta wsync sta $d01a pla }; end; // the RTI instruction gets inserted automatically pascal Using the PASCAL modifier will cause procedure/function to be treated as recursive. By default, the compiler automatically detects recursion, but there may be situations where this is not possible. Example samples/math/evaluate.pas stdcall Using the STDCALL modifier will force parameters to be passed to the procedure/function through the program stack. By default, the compiler tries to pass parameters through variables, without involving the program stack. inline The procedure, function is turned into a Mad-Assembler macro, getting rid of calls involving the JSR command. It is not possible to use recursion for such procedures/functions .","title":"Procedures, functions, modifiers"},{"location":"procedures-functions/#_1","text":"","title":""},{"location":"procedures-functions/#procedure","text":"Mad-Pascal allows up to 8 parameters to be transferred to the procedure. There are three ways to pass parameters - by value, constant CONST and variable VAR . It is possible to use the OVERLOAD modifier to overload procedures. Available procedure modifiers: OVERLOAD ASSEMBLER FORWARD REGISTER INTERRUPT PASCAL . Procedure parameters are read and valued from right to left tests\\tests-medium\\function_valuation_of_arguments.pas It is possible to recurse procedures, provided that the procedure parameters will be passed by value and will be of a simple - ordinal type. The record or pointer type will not be properly allocated in memory.","title":"Procedure"},{"location":"procedures-functions/#function","text":"Mad-Pascal allows you to transfer up to 8 parameters to the function. There are three ways to pass parameters - by value, constant CONST and variable VAR . We return the result of the function by assigning it to the function name or using the automatically declared RESULT variable, e.g: function add(a,b: word): cardinal; begin Result := a+b; end; function mul(a,b: word): cardinal; begin mul := a*b; end; Available function modifiers: OVERLOAD ASSEMBLER FORWARD REGISTER INTERRUPT PASCAL INTERRUPT not recommended for functions. Function parameters are read and valued from right to left tests\\tests-medium\\function_valuation_of_arguments.pas It is possible to recurse functions, provided that the function parameters will be passed by value and will be of a simple - ordinal type. The record or pointer type will not be properly allocated in memory.","title":"Function"},{"location":"procedures-functions/#modifiers","text":"","title":"Modifiers"},{"location":"procedures-functions/#assembler","text":"The procedures/functions marked by ASSEMBLER can only consist of an ASM block. The compiler does not analyze the syntax of such blocks, treats them as a comment, possible errors are caught only during the assembly. WARNING It is required to maintain the state of the X CPU6502 register, which is used to operate the Mad-Pascal software stack. procedure color(a: byte); assembler; asm { mva a 712 }; end;","title":"assembler"},{"location":"procedures-functions/#overload","text":"Overloaded procedures/functions are recognized by the parameter list. procedure sum(var i: integer; a,b: integer); overload; begin i := a+b; end; procedure sum(var i: integer; a,b,c: integer); overload; begin i := a+b+c; end; function fsum(a,b: word): cardinal; assembler; overload; asm { adw a b result }; end; function fsum(a,b: real): real; overload; begin Result := a+b; end;","title":"overload"},{"location":"procedures-functions/#forward","text":"If you want the procedure/function to be declared after its first call, use the FORWARD modifier. procedure name [(formal-parameter-list)]; forward; ... ... ... procedure name; begin end;","title":"forward"},{"location":"procedures-functions/#register","text":"Using REGISTER modifier causes the first three formal parameters of the procedure/function to be placed on the zero page, in 32-bit general-purpose registers EDX , ECX , EAX respectively. procedure name (a,b,c: cardinal); register; // a = edx // b = ecx // c = eax","title":"register"},{"location":"procedures-functions/#interrupt","text":"Procedures/Functions marked by INTERRUPT end with RTI instruction (instead of standard RTS ). Regardless of whether such procedure/function is called in the program, the compiler always generates code for it. It is recommended to use the ASM block for such procedure/function , otherwise the Mad Pascal software stack will be destroyed, which may lead to unstable program operation, including computer crashes. At the beginning of the procedure/function marked by INTERRUPT , the programmer must take care to keep the CPU registers A X Y , at the output to restore such registers, the compiler only inserts the final RTI command. procedure dli; interrupt; asm { pha lda #$c8 sta wsync sta $d01a pla }; end; // the RTI instruction gets inserted automatically","title":"interrupt"},{"location":"procedures-functions/#pascal","text":"Using the PASCAL modifier will cause procedure/function to be treated as recursive. By default, the compiler automatically detects recursion, but there may be situations where this is not possible. Example samples/math/evaluate.pas","title":"pascal"},{"location":"procedures-functions/#stdcall","text":"Using the STDCALL modifier will force parameters to be passed to the procedure/function through the program stack. By default, the compiler tries to pass parameters through variables, without involving the program stack.","title":"stdcall"},{"location":"procedures-functions/#inline","text":"The procedure, function is turned into a Mad-Assembler macro, getting rid of calls involving the JSR command. It is not possible to use recursion for such procedures/functions .","title":"inline"},{"location":"projects/","text":"Benchmark Suite author: zbyti platform: A8 sources Star Vagrant author: MADRAFi platform: A8 home page sources Old Mansion author: bocianu platform: A8 home page sources Pac Mad author: bocianu platform: A8 home page sources Flob author: bocianu platform: A8 home page sources","title":"Projects"},{"location":"projects/#_1","text":"","title":""},{"location":"projects/#benchmark-suite","text":"author: zbyti platform: A8 sources","title":"Benchmark Suite"},{"location":"projects/#star-vagrant","text":"author: MADRAFi platform: A8 home page sources","title":"Star Vagrant"},{"location":"projects/#old-mansion","text":"author: bocianu platform: A8 home page sources","title":"Old Mansion"},{"location":"projects/#pac-mad","text":"author: bocianu platform: A8 home page sources","title":"Pac Mad"},{"location":"projects/#flob","text":"author: bocianu platform: A8 home page sources","title":"Flob"},{"location":"resources/","text":"Resource files Syntax of RC files The RC files are plain text files. They contain a list of resources to be included in the compiled file. The basic syntax element looks as follows: RCLABEL RCTYPE RCFILE [PAR0, PAR1, PAR2, PAR3, PAR4, PAR5, PAR6, PAR7] The contents of a RC file may include comments, preceded by a ';' or '#' character. An example of a RC file: ; this is a MPT player mpt_player MPTPLAY # this is a MPT modul mpt_modul MPT 'porazka.mpt' The resource type specifies the format of the file to be included. Type Info RCDATA Any data type, e.g.: label RCDATA 'filename' label RCDATA 'filename' OFFSET EXTMEM Any data type loaded into PORTB secondary memory, loading address determined by RCLABEL . RCASM The assembler file that will be included and assembled. DOSFILE File with Atari DOS header, the loading address of such a file should be identical to RCLABEL . RELOC Relocatable file in Mad-Assembler format, the file will be relocated to the indicated RCLABEL address. RMT The Raster Music Tracker-a module file, the file will be relocated to the indicated RCLABEL address. MPT The Music ProTracker-a module file, the file will be relocated to the indicated RCLABEL address. CMC The Chaos Music Composer-a module file, the file will be relocated to the indicated RCLABEL address. SAPR SAP-R data file, the file will be relocated to the indicated RCLABEL address. RMTPLAY Player for RMT module, specify *.FEAT file as RCFILE and additionally PAR0 player mode 0..3: 0 => compile RMTplayer for 4 tracks mono 1 => compile RMTplayer for 8 tracks stereo 2 => compile RMTplayer for 4 tracks stereo L1 R2 R3 L4 3 => compile RMTplayer for 4 tracks stereo L1 L2 R3 R4 SAPRPLAY Player SAP-R LZSS , no need to specify file name RCFILE , address RCLABEL only from the beginning of the page. MPTPLAY Player for MPT module, no need to specify RCFILE file name. CMCPLAY Player for CMC module, no need to specify RCFILE file name. XBMP Windows Bitmap file (8 BitsPerPixel) loaded into VBXE memory at the indicated RCLABEL address from color index PAR0 in VBXE** color palette #1 Ability to load resources under ROM CMC RAM / ROM CMCPLAY RAM / ROM DOSFILE RAM / ROM EXTMEM MPT RAM / ROM MPTPLAY RAM / ROM RCASM RAM / ROM RCDATA RAM / ROM RELOC RAM RMT RAM / ROM RMTPLAY RAM XBMP SAPR RAM / ROM SAPRPLAY RAM / ROM Including an RC file in the application Insert a compiler directive in the program source code (e.g., at the beginning of the implementation section): {$R myresources.rc} In addition, specify in the program code the value for the RCLABEL labels of the corresponding resources, e.g.: const mpt_player = $8000; mpt_modul = $9000; The inclusion of the RC file occurs when the program is compiled. If the resource address points to an address under ROM ( $C000..$FFFF ) then ANTIC is disabled. At program startup, write the appropriate value to the DMACTL registry. to turn the image back on. Access to Resources Resources are placed at the indicated RCLABEL addresses in memory. The only exception is the RCDATA resource type for which it is possible to omit the RCLABEL definition from the program code. In the absence of a RCLABEL definition, the resource is included in the compiled program, accessed via the GetResourceHandle routine. GetResourceHandle(pointer, 'rclabel'); The GetResourceHandle procedure sets the value of the POINTER for the resource 'RCLABEL'.","title":"Resource files"},{"location":"resources/#_1","text":"","title":""},{"location":"resources/#resource-files","text":"","title":"Resource files"},{"location":"resources/#syntax-of-rc-files","text":"The RC files are plain text files. They contain a list of resources to be included in the compiled file. The basic syntax element looks as follows: RCLABEL RCTYPE RCFILE [PAR0, PAR1, PAR2, PAR3, PAR4, PAR5, PAR6, PAR7] The contents of a RC file may include comments, preceded by a ';' or '#' character. An example of a RC file: ; this is a MPT player mpt_player MPTPLAY # this is a MPT modul mpt_modul MPT 'porazka.mpt' The resource type specifies the format of the file to be included. Type Info RCDATA Any data type, e.g.: label RCDATA 'filename' label RCDATA 'filename' OFFSET EXTMEM Any data type loaded into PORTB secondary memory, loading address determined by RCLABEL . RCASM The assembler file that will be included and assembled. DOSFILE File with Atari DOS header, the loading address of such a file should be identical to RCLABEL . RELOC Relocatable file in Mad-Assembler format, the file will be relocated to the indicated RCLABEL address. RMT The Raster Music Tracker-a module file, the file will be relocated to the indicated RCLABEL address. MPT The Music ProTracker-a module file, the file will be relocated to the indicated RCLABEL address. CMC The Chaos Music Composer-a module file, the file will be relocated to the indicated RCLABEL address. SAPR SAP-R data file, the file will be relocated to the indicated RCLABEL address. RMTPLAY Player for RMT module, specify *.FEAT file as RCFILE and additionally PAR0 player mode 0..3: 0 => compile RMTplayer for 4 tracks mono 1 => compile RMTplayer for 8 tracks stereo 2 => compile RMTplayer for 4 tracks stereo L1 R2 R3 L4 3 => compile RMTplayer for 4 tracks stereo L1 L2 R3 R4 SAPRPLAY Player SAP-R LZSS , no need to specify file name RCFILE , address RCLABEL only from the beginning of the page. MPTPLAY Player for MPT module, no need to specify RCFILE file name. CMCPLAY Player for CMC module, no need to specify RCFILE file name. XBMP Windows Bitmap file (8 BitsPerPixel) loaded into VBXE memory at the indicated RCLABEL address from color index PAR0 in VBXE** color palette #1","title":"Syntax of RC files"},{"location":"resources/#ability-to-load-resources-under-rom","text":"CMC RAM / ROM CMCPLAY RAM / ROM DOSFILE RAM / ROM EXTMEM MPT RAM / ROM MPTPLAY RAM / ROM RCASM RAM / ROM RCDATA RAM / ROM RELOC RAM RMT RAM / ROM RMTPLAY RAM XBMP SAPR RAM / ROM SAPRPLAY RAM / ROM","title":"Ability to load resources under ROM"},{"location":"resources/#including-an-rc-file-in-the-application","text":"Insert a compiler directive in the program source code (e.g., at the beginning of the implementation section): {$R myresources.rc} In addition, specify in the program code the value for the RCLABEL labels of the corresponding resources, e.g.: const mpt_player = $8000; mpt_modul = $9000; The inclusion of the RC file occurs when the program is compiled. If the resource address points to an address under ROM ( $C000..$FFFF ) then ANTIC is disabled. At program startup, write the appropriate value to the DMACTL registry. to turn the image back on.","title":"Including an RC file in the application"},{"location":"resources/#access-to-resources","text":"Resources are placed at the indicated RCLABEL addresses in memory. The only exception is the RCDATA resource type for which it is possible to omit the RCLABEL definition from the program code. In the absence of a RCLABEL definition, the resource is included in the compiled program, accessed via the GetResourceHandle routine. GetResourceHandle(pointer, 'rclabel'); The GetResourceHandle procedure sets the value of the POINTER for the resource 'RCLABEL'.","title":"Access to Resources"},{"location":"syntax/","text":"Comments In Mad-Pascal // is used to mark a one-line comment and { } or (* *) mark a multiline comment. // this is a comment inc(a); // this also is a comment (* comment *) (* comment *) { this is a comment } Reserved identifiers reserved commands absolute and array asm assembler begin case const constructor div do downto else end exports external file for forward function if implementation in interrupt interface length library main mod not object of or overload pascal procedure program record register repeat shl shr string text textfile then to type unit until uses var while xor reserved constants pi true false nil eol nan infinity neginfinity Expressions Numbers decimal notation -100 -2437325 1743 hexadecimal notation $100 $e430 $000001 binary notation %0001001010 %000000001 %001000 ATASCII code notation 'a' 'fds' 'W' #65#32#65 #$9b Operators arithmetic + Addition - Subtraction * Multiplication / Division DIV Integer division MOD Remainder bitwise NOT Bitwise negation (unary) AND Bitwise and OR Bitwise or XOR Bitwise xor SHL Bitwise shift to the left SHR Bitwise shift to the right logical NOT logical negation (unary) AND logical and OR logical or XOR logical xor relational = Equal <> Not equal < Less than > Greater than <= Less than or equal >= Greater than or equal Compiler directives Compiler directives are of form:: {$directive parameters} {$list_of_switch_directives} A directive is a comment differentiated from a regular comment by the first $ character. CONDITIONAL {$IFDEF label} {$IFNDEF label} {$ELSE} {$ENDIF} {$DEFINE label} {$UNDEF label} {$define test} const {$ifdef test} a=1; {$else} a=2; {$endif} From the assembly level access to defined $DEFINE directives is only possible through MAIN.@DEFINES.label . $BIN2CSV Includes the contents of a external binary file, into the source code, like a CSV text. For example, if a binary file contains the bytes $1E, $1F, $20 , the directive will generates the string 30, 31, 32 . This directive can be used to initialize arrays . //Initialize with a binary content AAA: array[3] of byte = ({$BIN2CSV data.bin}); $CODEALIGN PROC = value The $CODEALIGN PROC directive allows the generated result code to be aligned to the VALUE bytes of the memory page. A .ALIGN VALUE code is inserted before each PROCEDURE , FUNCTION block. To disable alignment, set {$CODEALIGN PROC = 0} . $CODEALIGN LOOP = value The $CODEALIGN LOOP directive allows the generated result code to be aligned to the VALUE bytes of the memory page. A .ALIGN VALUE code is inserted before each FOR , WHILE , REPEAT iteration instruction. To disable alignment, set {$CODEALIGN LOOP = 0} . $CODEALIGN LINK = value The $CODEALIGN LINK directive allows the generated result code to be aligned to the VALUE bytes of the memory page. Before each {$LINK filename} directive, the .ALIGN VALUE code is inserted. To disable alignment, set {$CODEALIGN LINK = 0} . $DEFINE BASICOFF {$DEFINE BASICOFF} Additional code block that shutdown ATARI BASIC . ROMOFF {$DEFINE ROMOFF} We gain access to the memory under the ROM : $C000..$CFFF , $D800..$FFFF . The character set from ROM $E000..$E3FF is rewritten to the same address in RAM , the interrupt handler NMI , IRQ is installed. The operating system works normally, you can call the procedures contained in it from the ASM using the macro m@call . WARNING: When the ANTIC Display List program is placed under the ROM , each key press will trigger an IRQ interrupt that handles the keyboard. The ANTIC program will be interfered with by ROM - RAM switching, in case we use the Display List interrupt ( DLI ) the stack may be damaged and the system may crash. NOROMFONT {$DEFINE NOROMFONT} Supplement for {$DEFINE ROMOFF} , prevents rewriting of character set from ROM to RAM $ERROR {$ERROR user_defined} Generate error message. $F, $FASTMUL {$fastmul page} // fastmul at page*256 {$f $70} // fastmul at $7000 Alternative procedures for fast multiplication of the BYTE SHORTINT WORD SMALLINT SHORTREAL types. The procedures occupy 2KB and are located starting from the address PAGE*256 . $I+, $I-, IOCHECK {$I+} {$I-} {i+} IOCHECK ON default {i-} IOCHECK OFF For {$i+} in case of I/O transmission errors RESET REWRITE BLOCKREAD BLOCKWRITE CLOSE the ran program is stopped and an error diagnostic ERROR xxx is generated. Disabling IOCHECK {$i-} is of use for file existence checking, for example: function FileExists(name: TString): Boolean; var f: file; begin {$I-} // io check off Assign (f, name); Reset (f); Result:=(IoResult<128) and (length(name)>0); Close (f); {$I+} // io check on end; In PROCEDURE and FUNCTION blocks, the IOCHECK directive is of local scope, after finishing the compilation of such block the previous value of IOCHECK , defined outside of such block, is restored. $I, $INCLUDE %DATE% {$INCLUDE %DATE%} {$I %DATE%} Directive parameter %DATE% for inclusion of a string with current compilation date. %TIME% {$INCLUDE %TIME%} {$I %TIME%} Directive parameter %TIME% for inclusion of a string with current compilation time. FILENAME {$INCLUDE filename} {$I filename} Directive parameter FILENAME to attach the text contained in the file. $INFO {$INFO user_defined} Generate info message. $LIBRARYPATH {$LIBRARYPATH path1;path2;...} Directive to indicate additional search paths for libraries unit . $LINK {$LINK filename} The {$link filename} directive allows you to include and integrate code and procedures assembled in Mad Pascal program. For more on linking the assembler to Mad Pascal , see Assembler Insertions . $MACRO {$MACRO ON} {$MACRO OFF} {$MACRO+} {$MACRO-} The {$macro } directive enables/disables the ability to define macros , is required by FPC , in Mad-Pascal it is retained for compatibility purposes only. $OPTIMIZATION LOOPUNROLL {$OPTIMIZATION loopunroll} The $OPTIMIZATION directive with the LOOPUNROLL parameter allows you to unroll FOR loops (the parameters of such a loop must be constants): {$OPTIMIZATION loopunroll} for i:=0 to 11 do tab[i]:=i*2; {$OPTIMIZATION noloopunroll} NOLOOPUNROLL {$OPTIMIZATION noloopunroll} The NOLOOPUNROLL parameter disables the FOR loop unroll. $R, $RESOURCE {$R filename} {$RESOURCE filename} RCLABEL RCTYPE RCFILE [PAR0 PAR1 PAR2 PAR3 PAR4 PAR5 PAR6 PAR7] Directive to load a resource file . A resource file is a text file, each of its successive lines should consist of three fields separated by a whitespace character : RCLABEL , the label (its declaration can be included in the program), RCTYPE , the resource type and RCFILE , the file location.The base\\<platform>\\resource.asm file contains macros to support the different types of RCTYPE resources: RCDATA Any data type. EXTMEM Any data type loaded into PORTB secondary memory, loading address determined by RCLABEL . RCASM An assembly file that will be attached and assembled. DOSFILE Atari DOS header file, the loading address of such a file should be the same as RCLABEL . RELOC A relocatable file in MadAssembler format, the file will be relocated to the address indicated by RCLABEL . RMT Raster Music Tracker module file, the file will be relocated to the address indicated by RCLABEL . MPT The Music ProTracker module file, the file will be relocated to the indicated address RCLABEL . CMC Chaos Music Composer module file, the file will be relocated to the address indicated by RCLABEL . RMTPLAY Player for the RMT module, with the *.FEAT file passed as the RCFILE and the player mode 0..3 passed as the PAR0 . 0 => compile RMTplayer for 4 tracks mono 1 => compile RMTplayer for 8 tracks stereo 2 => compile RMTplayer for 4 tracks stereo L1 R2 R3 L4 3 => compile RMTplayer for 4 tracks stereo L1 L2 R3 R4 MPTPLAY Player for MPT module. CMCPLAY Player for CMC module. XBMP Windows Bitmap file (8 BitsPerPixel) loaded into VBXE memory to the indicated address RCLABEL from PAR0 color index in VBXE color palette no. 1. Example: bmp1 RCDATA 'pic.mic' msx MPT 'porazka.mpt' play RMTPLAY 'modul.feat' 1 bmp XBMP 'pic.bmp' 80 $WARNING {$WARNING user_defined} Generate warning message.","title":"Syntax"},{"location":"syntax/#_1","text":"","title":""},{"location":"syntax/#comments","text":"In Mad-Pascal // is used to mark a one-line comment and { } or (* *) mark a multiline comment. // this is a comment inc(a); // this also is a comment (* comment *) (* comment *) { this is a comment }","title":"Comments"},{"location":"syntax/#reserved-identifiers","text":"","title":"Reserved identifiers"},{"location":"syntax/#reserved-commands","text":"absolute and array asm assembler begin case const constructor div do downto else end exports external file for forward function if implementation in interrupt interface length library main mod not object of or overload pascal procedure program record register repeat shl shr string text textfile then to type unit until uses var while xor","title":"reserved commands"},{"location":"syntax/#reserved-constants","text":"pi true false nil eol nan infinity neginfinity","title":"reserved constants"},{"location":"syntax/#expressions","text":"","title":"Expressions"},{"location":"syntax/#numbers","text":"","title":"Numbers"},{"location":"syntax/#decimal-notation","text":"-100 -2437325 1743","title":"decimal notation"},{"location":"syntax/#hexadecimal-notation","text":"$100 $e430 $000001","title":"hexadecimal notation"},{"location":"syntax/#binary-notation","text":"%0001001010 %000000001 %001000","title":"binary notation"},{"location":"syntax/#atascii-code-notation","text":"'a' 'fds' 'W' #65#32#65 #$9b","title":"ATASCII code notation"},{"location":"syntax/#operators","text":"","title":"Operators"},{"location":"syntax/#arithmetic","text":"+ Addition - Subtraction * Multiplication / Division DIV Integer division MOD Remainder","title":"arithmetic"},{"location":"syntax/#bitwise","text":"NOT Bitwise negation (unary) AND Bitwise and OR Bitwise or XOR Bitwise xor SHL Bitwise shift to the left SHR Bitwise shift to the right","title":"bitwise"},{"location":"syntax/#logical","text":"NOT logical negation (unary) AND logical and OR logical or XOR logical xor","title":"logical"},{"location":"syntax/#relational","text":"= Equal <> Not equal < Less than > Greater than <= Less than or equal >= Greater than or equal","title":"relational"},{"location":"syntax/#compiler-directives","text":"Compiler directives are of form:: {$directive parameters} {$list_of_switch_directives} A directive is a comment differentiated from a regular comment by the first $ character.","title":"Compiler directives"},{"location":"syntax/#conditional","text":"{$IFDEF label} {$IFNDEF label} {$ELSE} {$ENDIF} {$DEFINE label} {$UNDEF label} {$define test} const {$ifdef test} a=1; {$else} a=2; {$endif} From the assembly level access to defined $DEFINE directives is only possible through MAIN.@DEFINES.label .","title":"CONDITIONAL"},{"location":"syntax/#bin2csv","text":"Includes the contents of a external binary file, into the source code, like a CSV text. For example, if a binary file contains the bytes $1E, $1F, $20 , the directive will generates the string 30, 31, 32 . This directive can be used to initialize arrays . //Initialize with a binary content AAA: array[3] of byte = ({$BIN2CSV data.bin});","title":"$BIN2CSV"},{"location":"syntax/#codealign-proc-value","text":"The $CODEALIGN PROC directive allows the generated result code to be aligned to the VALUE bytes of the memory page. A .ALIGN VALUE code is inserted before each PROCEDURE , FUNCTION block. To disable alignment, set {$CODEALIGN PROC = 0} .","title":"$CODEALIGN PROC = value"},{"location":"syntax/#codealign-loop-value","text":"The $CODEALIGN LOOP directive allows the generated result code to be aligned to the VALUE bytes of the memory page. A .ALIGN VALUE code is inserted before each FOR , WHILE , REPEAT iteration instruction. To disable alignment, set {$CODEALIGN LOOP = 0} .","title":"$CODEALIGN LOOP = value"},{"location":"syntax/#codealign-link-value","text":"The $CODEALIGN LINK directive allows the generated result code to be aligned to the VALUE bytes of the memory page. Before each {$LINK filename} directive, the .ALIGN VALUE code is inserted. To disable alignment, set {$CODEALIGN LINK = 0} .","title":"$CODEALIGN LINK = value"},{"location":"syntax/#define","text":"","title":"$DEFINE"},{"location":"syntax/#basicoff","text":"{$DEFINE BASICOFF} Additional code block that shutdown ATARI BASIC .","title":"BASICOFF"},{"location":"syntax/#romoff","text":"{$DEFINE ROMOFF} We gain access to the memory under the ROM : $C000..$CFFF , $D800..$FFFF . The character set from ROM $E000..$E3FF is rewritten to the same address in RAM , the interrupt handler NMI , IRQ is installed. The operating system works normally, you can call the procedures contained in it from the ASM using the macro m@call . WARNING: When the ANTIC Display List program is placed under the ROM , each key press will trigger an IRQ interrupt that handles the keyboard. The ANTIC program will be interfered with by ROM - RAM switching, in case we use the Display List interrupt ( DLI ) the stack may be damaged and the system may crash.","title":"ROMOFF"},{"location":"syntax/#noromfont","text":"{$DEFINE NOROMFONT} Supplement for {$DEFINE ROMOFF} , prevents rewriting of character set from ROM to RAM","title":"NOROMFONT"},{"location":"syntax/#error","text":"{$ERROR user_defined} Generate error message.","title":"$ERROR"},{"location":"syntax/#f-fastmul","text":"{$fastmul page} // fastmul at page*256 {$f $70} // fastmul at $7000 Alternative procedures for fast multiplication of the BYTE SHORTINT WORD SMALLINT SHORTREAL types. The procedures occupy 2KB and are located starting from the address PAGE*256 .","title":"$F, $FASTMUL"},{"location":"syntax/#i-i-iocheck","text":"{$I+} {$I-} {i+} IOCHECK ON default {i-} IOCHECK OFF For {$i+} in case of I/O transmission errors RESET REWRITE BLOCKREAD BLOCKWRITE CLOSE the ran program is stopped and an error diagnostic ERROR xxx is generated. Disabling IOCHECK {$i-} is of use for file existence checking, for example: function FileExists(name: TString): Boolean; var f: file; begin {$I-} // io check off Assign (f, name); Reset (f); Result:=(IoResult<128) and (length(name)>0); Close (f); {$I+} // io check on end; In PROCEDURE and FUNCTION blocks, the IOCHECK directive is of local scope, after finishing the compilation of such block the previous value of IOCHECK , defined outside of such block, is restored.","title":"$I+, $I-, IOCHECK"},{"location":"syntax/#i-include","text":"","title":"$I, $INCLUDE"},{"location":"syntax/#date","text":"{$INCLUDE %DATE%} {$I %DATE%} Directive parameter %DATE% for inclusion of a string with current compilation date.","title":"%DATE%"},{"location":"syntax/#time","text":"{$INCLUDE %TIME%} {$I %TIME%} Directive parameter %TIME% for inclusion of a string with current compilation time.","title":"%TIME%"},{"location":"syntax/#filename","text":"{$INCLUDE filename} {$I filename} Directive parameter FILENAME to attach the text contained in the file.","title":"FILENAME"},{"location":"syntax/#info","text":"{$INFO user_defined} Generate info message.","title":"$INFO"},{"location":"syntax/#librarypath","text":"{$LIBRARYPATH path1;path2;...} Directive to indicate additional search paths for libraries unit .","title":"$LIBRARYPATH"},{"location":"syntax/#link","text":"{$LINK filename} The {$link filename} directive allows you to include and integrate code and procedures assembled in Mad Pascal program. For more on linking the assembler to Mad Pascal , see Assembler Insertions .","title":"$LINK"},{"location":"syntax/#macro","text":"{$MACRO ON} {$MACRO OFF} {$MACRO+} {$MACRO-} The {$macro } directive enables/disables the ability to define macros , is required by FPC , in Mad-Pascal it is retained for compatibility purposes only.","title":"$MACRO"},{"location":"syntax/#optimization","text":"","title":"$OPTIMIZATION"},{"location":"syntax/#loopunroll","text":"{$OPTIMIZATION loopunroll} The $OPTIMIZATION directive with the LOOPUNROLL parameter allows you to unroll FOR loops (the parameters of such a loop must be constants): {$OPTIMIZATION loopunroll} for i:=0 to 11 do tab[i]:=i*2; {$OPTIMIZATION noloopunroll}","title":"LOOPUNROLL"},{"location":"syntax/#noloopunroll","text":"{$OPTIMIZATION noloopunroll} The NOLOOPUNROLL parameter disables the FOR loop unroll.","title":"NOLOOPUNROLL"},{"location":"syntax/#r-resource","text":"{$R filename} {$RESOURCE filename} RCLABEL RCTYPE RCFILE [PAR0 PAR1 PAR2 PAR3 PAR4 PAR5 PAR6 PAR7] Directive to load a resource file . A resource file is a text file, each of its successive lines should consist of three fields separated by a whitespace character : RCLABEL , the label (its declaration can be included in the program), RCTYPE , the resource type and RCFILE , the file location.The base\\<platform>\\resource.asm file contains macros to support the different types of RCTYPE resources:","title":"$R, $RESOURCE"},{"location":"syntax/#rcdata","text":"Any data type.","title":"RCDATA"},{"location":"syntax/#extmem","text":"Any data type loaded into PORTB secondary memory, loading address determined by RCLABEL .","title":"EXTMEM"},{"location":"syntax/#rcasm","text":"An assembly file that will be attached and assembled.","title":"RCASM"},{"location":"syntax/#dosfile","text":"Atari DOS header file, the loading address of such a file should be the same as RCLABEL .","title":"DOSFILE"},{"location":"syntax/#reloc","text":"A relocatable file in MadAssembler format, the file will be relocated to the address indicated by RCLABEL .","title":"RELOC"},{"location":"syntax/#rmt","text":"Raster Music Tracker module file, the file will be relocated to the address indicated by RCLABEL .","title":"RMT"},{"location":"syntax/#mpt","text":"The Music ProTracker module file, the file will be relocated to the indicated address RCLABEL .","title":"MPT"},{"location":"syntax/#cmc","text":"Chaos Music Composer module file, the file will be relocated to the address indicated by RCLABEL .","title":"CMC"},{"location":"syntax/#rmtplay","text":"Player for the RMT module, with the *.FEAT file passed as the RCFILE and the player mode 0..3 passed as the PAR0 . 0 => compile RMTplayer for 4 tracks mono 1 => compile RMTplayer for 8 tracks stereo 2 => compile RMTplayer for 4 tracks stereo L1 R2 R3 L4 3 => compile RMTplayer for 4 tracks stereo L1 L2 R3 R4","title":"RMTPLAY"},{"location":"syntax/#mptplay","text":"Player for MPT module.","title":"MPTPLAY"},{"location":"syntax/#cmcplay","text":"Player for CMC module.","title":"CMCPLAY"},{"location":"syntax/#xbmp","text":"Windows Bitmap file (8 BitsPerPixel) loaded into VBXE memory to the indicated address RCLABEL from PAR0 color index in VBXE color palette no. 1. Example: bmp1 RCDATA 'pic.mic' msx MPT 'porazka.mpt' play RMTPLAY 'modul.feat' 1 bmp XBMP 'pic.bmp' 80","title":"XBMP"},{"location":"syntax/#warning","text":"{$WARNING user_defined} Generate warning message.","title":"$WARNING"},{"location":"tips/","text":"FOR The counter value at the end of the FOR iterative instruction in FPC will be equal to the value that was specified for the maximum counter value. In the case of Mad-Pascal , the value will be larger by +1 . Example: for i:=0 to 10 do; FPC at the end of the loop i = 10', **Mad-Pascal** i = 11' SHL FPC provides other results for SHL that exceeds the size of the type, such as: i: byte; c: cardinal; i:=1; c:=i shl 33; For the above example, FPC will return a value of 2, Mad-Pascal will return 0. Whereas for: c:=1 shl 33; STRINGS IN MEMORY writeln('ala','ma','kota'); writeln('ala','ma','psa'); The compiler will only put back the character strings ala , ma once in memory. By breaking a longer string into smaller pieces, we can save memory. CHARS IN MEMORY writeln(#69,#82,#82,#32, a); Character codes separated by a comma will not be treated as strings that the compiler writes to constants. SHORTER BOOLEAN TERMS if spanbelow = true then ; can be replaced by if spanbelow then ; INFINITE LOOP When assembling a *.a65 file causes an 'Infinite loop', the OBX file is saved but is corrupted. To get rid of this situation, set `DATAORIGIN' (-data:ADDRESS) hard. USES The order of the modules in the USES list can make a difference.","title":"Tips and tricks"},{"location":"tips/#_1","text":"","title":""},{"location":"tips/#for","text":"The counter value at the end of the FOR iterative instruction in FPC will be equal to the value that was specified for the maximum counter value. In the case of Mad-Pascal , the value will be larger by +1 . Example: for i:=0 to 10 do; FPC at the end of the loop i = 10', **Mad-Pascal** i = 11'","title":"FOR"},{"location":"tips/#shl","text":"FPC provides other results for SHL that exceeds the size of the type, such as: i: byte; c: cardinal; i:=1; c:=i shl 33; For the above example, FPC will return a value of 2, Mad-Pascal will return 0. Whereas for: c:=1 shl 33;","title":"SHL"},{"location":"tips/#strings-in-memory","text":"writeln('ala','ma','kota'); writeln('ala','ma','psa'); The compiler will only put back the character strings ala , ma once in memory. By breaking a longer string into smaller pieces, we can save memory.","title":"STRINGS IN MEMORY"},{"location":"tips/#chars-in-memory","text":"writeln(#69,#82,#82,#32, a); Character codes separated by a comma will not be treated as strings that the compiler writes to constants.","title":"CHARS IN MEMORY"},{"location":"tips/#shorter-boolean-terms","text":"if spanbelow = true then ; can be replaced by if spanbelow then ;","title":"SHORTER BOOLEAN TERMS"},{"location":"tips/#infinite-loop","text":"When assembling a *.a65 file causes an 'Infinite loop', the OBX file is saved but is corrupted. To get rid of this situation, set `DATAORIGIN' (-data:ADDRESS) hard.","title":"INFINITE LOOP"},{"location":"tips/#uses","text":"The order of the modules in the USES list can make a difference.","title":"USES"},{"location":"types/","text":"Ordinal types Type Range Size in bytes BYTE 0 .. 255 1 SHORTINT -128 .. 127 1 WORD 0 .. 65535 2 SMALLINT -32768 .. 32767 2 CARDINAL 0 .. 4294967295 4 LONGWORD 0 .. 4294967295 4 DWORD 0 .. 4294967295 4 UINT32 0 .. 4294967295 4 INTEGER -2147483648 .. 2147483647 4 LONGINT -2147483648 .. 2147483647 4 Boolean types Type Ord(True) Size in bytes BOOLEAN 1 1 Enumeration types The enumeration type in Mad-Pascal has been implemented in its basic form, i.e.: Type Days = (monday,tuesday,wednesday,thursday,friday, saturday,sunday); Joy = (right_down = 5, right_up, right, left_down = 9, left_up, left, down = 13, up, none); The enumeration type is stored only in the memory of the Mad-Pascal compiler, no information about the enumeration type fields will be stored in the result file. It is permissible to use the ORD , SIZEOF and casts on the enumeration type. var d: Days; d:=friday; writeln(ord(d)); writeln(ord(sunday)); writeln(sizeof(days)); writeln(sizeof(monday)); d:=days(20); case d of sunday: writeln('sunday'); end; Currently, the Mad-Pascal compiler does not check the correctness of enumeration types for IF ELSE operations. Real types Type Range Size in bytes SHORTREAL (Q8.8) -128..127 2 REAL (Q24.8) -8388608..8388607 4 SINGLE (IEEE-754) 1.5E-45 .. 3.4E38 4 FLOAT (IEEE-754) 1.5E-45 .. 3.4E38 4 FLOAT16 (IEEE-754) 65504 .. -65504 2 Conversion of FLOAT SINGLE to INTEGER type is only available in the range INTEGER . The INTEGER type will not allow to present the maximum value 3.4E38 of FLOAT SINGLE type. Char types Type Range Size in bytes CHAR ATASCII (0 .. 255) 1 STRING 1 .. 255 256 PCHAR 0 .. 65535 2 The STRING is represented as an array with a possible maximum size [0..255] . The first byte of such an array [0] is the string length from the range 0..255 . The actual character string begins from the byte [1..] . A pointer to the CHAR type represents the PCHAR string. The terminator of the PCHAR string is the #0 character. It is allowed to use additional characters after the final apostrophe, such as * , ~ . The character * means a string in the inverse; the tilde ~ means a string in ANTIC codes. Another way to modify the output characters is to use the system variable TextAttr , each character output to the screen is increased by the value TextAttr (default = 0). a: string = 'Atari'*; // a character string in the inverse b: string = 'Spectrum'~; // a character string in ANTIC codes c: char = 'X'~*; // a character in inverted ANTIC codes Pointers Type Range Size in bytes POINTER 0 .. 65535 2 Indicators in Mad-Pascal can be typed and without a specific type, e.g.: a: ^word; // a typed pointer to a word b: pointer; // an untyped pointer An uninitialized pointer will most often have the address of $0000 , you should make sure that before you use it, you will have initialized it with the address of the appropriate variable, e.g.: a := @tmp; // pointer A is assigned the address of the TMP variable If you don't do this, if you run such a program on a PC , you may cause a memory protection fault Access Violation . Increasing the pointer using INC increases it by the size of the type it indicates. Decreasing the pointer using DEC reduces it by the size of the type it indicates. If the type is unspecified, the default step for increase/decrease is 1 . For pointers, relation operations = , <> , < , <= , > , >= , and arithmetic operations + and - are allowed. Using a pointer, we can cast a variable to another type: var s: single; d: cardinal; begin s := 3.14; d:=PCardinal(@s)^; // d = $4048F5C3 end; Static arrays Tables in Mad-Pascal are only static, one-dimensional or two-dimensional with an initial index equal to 0 , e.g: var tb: array [0..100] of word; var tb2: array [0..15, 0..31] of Boolean; For an initial index other than zero, an error Error Array lower bound is not zero is generated. In the memory the array is represented by the pointer POINTER , the pointer is the address of the array in memory (WORD). The quickest way to refer to the table from the assembler level is to use the prefix ADR , e.g.: asm { lda adr.tb,y ; direct reference to the TB array lda tb ; reference to the TB array pointer }; The compiler generates code for the arrays depending on their declaration: when the number of bytes does not exceed 256 bytes array [0..255] of byte array [0..127] of word array [0..63] of cardinal When the number of bytes occupied by the array does not exceed 256 bytes, the fastest code referring directly to the address of the array (prefix ADR. ) is generated without the pointer. It is not possible to change the address for such an array. ldy #118 lda adr.tb,y when the number of elements of an array is 1 array [0..0] of type When the number of elements of an array is 1 it is treated specifically. The code generated refers to the array through the pointer. It is possible to set a new address for such a table. lda TB add I tay lda TB+1 adc #$00 sta bp+1 lda (bp),y when the number of bytes exceeds 256 bytes array [0..255+1] of byte array [0..127+1] of word array [0..63+1] of cardinal When the number of bytes occupied by the array exceeds 256 bytes, the generated code refers to the array via an pointer. When the number of bytes occupied by the array exceeds 256 bytes, the generated code refers to the array through a pointer. lda TB add I tay lda TB+1 adc #$00 sta bp+1 lda (bp),y Record types In the memory the record is represented by a pointer POINTER . type TPoint = record x,y: byte end; var px: TPoint; By default, records in Mad-Pascal are of type PACKED . The total size of the record fields is limited to 256 bytes. If you want to maintain FPC compatibility, you should additionally precede the word record with the word packed . Without this, the size of the memory that the record takes varies, it occupies less memory on MOS 6502 target, potentially several bytes more on Windows . type TPoint = packed record x,y: byte end; var px: TPoint; Access to record fields from the assembly: mwa px bp2 ldy #px.x-DATAORIGIN lda (bp2),y Table of records Mad-Pascal only supports arrays of record pointers. type TPoint = record x,y: byte end; var tab: array [0..3] of ^TPoint; Such an array must be instantiated with the corresponding record addresses, by default all fields of such an array are zeroed at the beginning. The first way to instantiate an array of record indicators: var a1,a2,a3,a4: TPoint; begin tab[0] := @a1; tab[1] := @a2; tab[2] := @a3; tab[3] := @a4; end. Second way: begin GetMem(tab[0], sizeof(TPoint)); GetMem(tab[1], sizeof(TPoint)); GetMem(tab[2], sizeof(TPoint)); GetMem(tab[3], sizeof(TPoint)); end. Access record fields from such an array: writeln(tab[1].x); writeln(tab[1].y); Object types Objects are records with additional methods. In the memory, the object is represented by a pointer POINTER . type TRMT = Object player: pointer; modul: pointer; procedure Init(a: byte); assembler; procedure Play; assembler; procedure Stop; assembler; end; It is possible to use the CONSTRUCTOR and DESTRUCTOR procedures in objects. Such procedures can only be called manually. Procedural In memory, procedural type variables are represented by the POINTER type. type tprc = procedure (a: byte; c: word); tfun = function (a:smallint; x: single): byte; var fn: function (a,b,c: byte): word; For the procedural type, procedures/functions with arguments require the STDCALL modifier, which will force the use of the program stack. var fn: function (a,b: word): word; function test(a,b,c,d: word): word; stdcall; begin end; begin fn := @test; fn(1,2); end; For procedures with arguments instead of the STDCALL modifier, the REGISTER modifier is allowed, provided there are up to three arguments. var prc: procedure (a,b: word); procedure test(a,b,c: cardinal); register; begin // a -> EDX // b -> ECX // c -> EAX end; begin prc := @test; prc(3,6); end; When no arguments are passed to the procedure/function, the use of modifier is not necessary. File types The FILE type represents the file handle and defines the record size. type ftype = array [0..63] of cardinal; var f: file; // default record =128 bytes f: file of byte; // 1 byte record f: file of ftype; // 256 byte record (ftype = 64 * 4) In the Atari 8-Bit memory, the FILE holder is represented by a pointer POINTER to an array of structure (size 12 bytes): .struct s@file pfname .word ; pointer to string with filename record .word ; record size chanel .byte ; channel *$10 eof .byte ; EOF status buffer .word ; load/write buffer nrecord .word ; number of records for load/write numread .word ; pointer to variable, length of loaded data .ends For procedures and functions, the FILE type can only be passed as a variable VAR . Untyped procedure Something (var Data); procedure Something (const Data); Failure to specify the type of the parameter means that only the address of the parameter without the type designation will be passed to the procedure/function. This is equivalent to the following C/C++ declaration: void Something(void* Data); Inside a procedure/function with an unsigned parameter, if an unsigned parameter is used in an expression or a value must be assigned to it, always use type casting. var x: word; procedure test(var a); begin writeln(PWord(@a)^); // = 95 PWord(@a)^ := 11; end; begin x:=95; test(x); // = 11 end.","title":"Types"},{"location":"types/#_1","text":"","title":""},{"location":"types/#ordinal-types","text":"Type Range Size in bytes BYTE 0 .. 255 1 SHORTINT -128 .. 127 1 WORD 0 .. 65535 2 SMALLINT -32768 .. 32767 2 CARDINAL 0 .. 4294967295 4 LONGWORD 0 .. 4294967295 4 DWORD 0 .. 4294967295 4 UINT32 0 .. 4294967295 4 INTEGER -2147483648 .. 2147483647 4 LONGINT -2147483648 .. 2147483647 4","title":"Ordinal types"},{"location":"types/#boolean-types","text":"Type Ord(True) Size in bytes BOOLEAN 1 1","title":"Boolean types"},{"location":"types/#enumeration-types","text":"The enumeration type in Mad-Pascal has been implemented in its basic form, i.e.: Type Days = (monday,tuesday,wednesday,thursday,friday, saturday,sunday); Joy = (right_down = 5, right_up, right, left_down = 9, left_up, left, down = 13, up, none); The enumeration type is stored only in the memory of the Mad-Pascal compiler, no information about the enumeration type fields will be stored in the result file. It is permissible to use the ORD , SIZEOF and casts on the enumeration type. var d: Days; d:=friday; writeln(ord(d)); writeln(ord(sunday)); writeln(sizeof(days)); writeln(sizeof(monday)); d:=days(20); case d of sunday: writeln('sunday'); end; Currently, the Mad-Pascal compiler does not check the correctness of enumeration types for IF ELSE operations.","title":"Enumeration types"},{"location":"types/#real-types","text":"Type Range Size in bytes SHORTREAL (Q8.8) -128..127 2 REAL (Q24.8) -8388608..8388607 4 SINGLE (IEEE-754) 1.5E-45 .. 3.4E38 4 FLOAT (IEEE-754) 1.5E-45 .. 3.4E38 4 FLOAT16 (IEEE-754) 65504 .. -65504 2 Conversion of FLOAT SINGLE to INTEGER type is only available in the range INTEGER . The INTEGER type will not allow to present the maximum value 3.4E38 of FLOAT SINGLE type.","title":"Real types"},{"location":"types/#char-types","text":"Type Range Size in bytes CHAR ATASCII (0 .. 255) 1 STRING 1 .. 255 256 PCHAR 0 .. 65535 2 The STRING is represented as an array with a possible maximum size [0..255] . The first byte of such an array [0] is the string length from the range 0..255 . The actual character string begins from the byte [1..] . A pointer to the CHAR type represents the PCHAR string. The terminator of the PCHAR string is the #0 character. It is allowed to use additional characters after the final apostrophe, such as * , ~ . The character * means a string in the inverse; the tilde ~ means a string in ANTIC codes. Another way to modify the output characters is to use the system variable TextAttr , each character output to the screen is increased by the value TextAttr (default = 0). a: string = 'Atari'*; // a character string in the inverse b: string = 'Spectrum'~; // a character string in ANTIC codes c: char = 'X'~*; // a character in inverted ANTIC codes","title":"Char types"},{"location":"types/#pointers","text":"Type Range Size in bytes POINTER 0 .. 65535 2 Indicators in Mad-Pascal can be typed and without a specific type, e.g.: a: ^word; // a typed pointer to a word b: pointer; // an untyped pointer An uninitialized pointer will most often have the address of $0000 , you should make sure that before you use it, you will have initialized it with the address of the appropriate variable, e.g.: a := @tmp; // pointer A is assigned the address of the TMP variable If you don't do this, if you run such a program on a PC , you may cause a memory protection fault Access Violation . Increasing the pointer using INC increases it by the size of the type it indicates. Decreasing the pointer using DEC reduces it by the size of the type it indicates. If the type is unspecified, the default step for increase/decrease is 1 . For pointers, relation operations = , <> , < , <= , > , >= , and arithmetic operations + and - are allowed. Using a pointer, we can cast a variable to another type: var s: single; d: cardinal; begin s := 3.14; d:=PCardinal(@s)^; // d = $4048F5C3 end;","title":"Pointers"},{"location":"types/#static-arrays","text":"Tables in Mad-Pascal are only static, one-dimensional or two-dimensional with an initial index equal to 0 , e.g: var tb: array [0..100] of word; var tb2: array [0..15, 0..31] of Boolean; For an initial index other than zero, an error Error Array lower bound is not zero is generated. In the memory the array is represented by the pointer POINTER , the pointer is the address of the array in memory (WORD). The quickest way to refer to the table from the assembler level is to use the prefix ADR , e.g.: asm { lda adr.tb,y ; direct reference to the TB array lda tb ; reference to the TB array pointer }; The compiler generates code for the arrays depending on their declaration: when the number of bytes does not exceed 256 bytes array [0..255] of byte array [0..127] of word array [0..63] of cardinal When the number of bytes occupied by the array does not exceed 256 bytes, the fastest code referring directly to the address of the array (prefix ADR. ) is generated without the pointer. It is not possible to change the address for such an array. ldy #118 lda adr.tb,y when the number of elements of an array is 1 array [0..0] of type When the number of elements of an array is 1 it is treated specifically. The code generated refers to the array through the pointer. It is possible to set a new address for such a table. lda TB add I tay lda TB+1 adc #$00 sta bp+1 lda (bp),y when the number of bytes exceeds 256 bytes array [0..255+1] of byte array [0..127+1] of word array [0..63+1] of cardinal When the number of bytes occupied by the array exceeds 256 bytes, the generated code refers to the array via an pointer. When the number of bytes occupied by the array exceeds 256 bytes, the generated code refers to the array through a pointer. lda TB add I tay lda TB+1 adc #$00 sta bp+1 lda (bp),y","title":"Static arrays"},{"location":"types/#record-types","text":"In the memory the record is represented by a pointer POINTER . type TPoint = record x,y: byte end; var px: TPoint; By default, records in Mad-Pascal are of type PACKED . The total size of the record fields is limited to 256 bytes. If you want to maintain FPC compatibility, you should additionally precede the word record with the word packed . Without this, the size of the memory that the record takes varies, it occupies less memory on MOS 6502 target, potentially several bytes more on Windows . type TPoint = packed record x,y: byte end; var px: TPoint; Access to record fields from the assembly: mwa px bp2 ldy #px.x-DATAORIGIN lda (bp2),y","title":"Record types"},{"location":"types/#table-of-records","text":"Mad-Pascal only supports arrays of record pointers. type TPoint = record x,y: byte end; var tab: array [0..3] of ^TPoint; Such an array must be instantiated with the corresponding record addresses, by default all fields of such an array are zeroed at the beginning. The first way to instantiate an array of record indicators: var a1,a2,a3,a4: TPoint; begin tab[0] := @a1; tab[1] := @a2; tab[2] := @a3; tab[3] := @a4; end. Second way: begin GetMem(tab[0], sizeof(TPoint)); GetMem(tab[1], sizeof(TPoint)); GetMem(tab[2], sizeof(TPoint)); GetMem(tab[3], sizeof(TPoint)); end. Access record fields from such an array: writeln(tab[1].x); writeln(tab[1].y);","title":"Table of records"},{"location":"types/#object-types","text":"Objects are records with additional methods. In the memory, the object is represented by a pointer POINTER . type TRMT = Object player: pointer; modul: pointer; procedure Init(a: byte); assembler; procedure Play; assembler; procedure Stop; assembler; end; It is possible to use the CONSTRUCTOR and DESTRUCTOR procedures in objects. Such procedures can only be called manually.","title":"Object types"},{"location":"types/#procedural","text":"In memory, procedural type variables are represented by the POINTER type. type tprc = procedure (a: byte; c: word); tfun = function (a:smallint; x: single): byte; var fn: function (a,b,c: byte): word; For the procedural type, procedures/functions with arguments require the STDCALL modifier, which will force the use of the program stack. var fn: function (a,b: word): word; function test(a,b,c,d: word): word; stdcall; begin end; begin fn := @test; fn(1,2); end; For procedures with arguments instead of the STDCALL modifier, the REGISTER modifier is allowed, provided there are up to three arguments. var prc: procedure (a,b: word); procedure test(a,b,c: cardinal); register; begin // a -> EDX // b -> ECX // c -> EAX end; begin prc := @test; prc(3,6); end; When no arguments are passed to the procedure/function, the use of modifier is not necessary.","title":"Procedural"},{"location":"types/#file-types","text":"The FILE type represents the file handle and defines the record size. type ftype = array [0..63] of cardinal; var f: file; // default record =128 bytes f: file of byte; // 1 byte record f: file of ftype; // 256 byte record (ftype = 64 * 4) In the Atari 8-Bit memory, the FILE holder is represented by a pointer POINTER to an array of structure (size 12 bytes): .struct s@file pfname .word ; pointer to string with filename record .word ; record size chanel .byte ; channel *$10 eof .byte ; EOF status buffer .word ; load/write buffer nrecord .word ; number of records for load/write numread .word ; pointer to variable, length of loaded data .ends For procedures and functions, the FILE type can only be passed as a variable VAR .","title":"File types"},{"location":"types/#untyped","text":"procedure Something (var Data); procedure Something (const Data); Failure to specify the type of the parameter means that only the address of the parameter without the type designation will be passed to the procedure/function. This is equivalent to the following C/C++ declaration: void Something(void* Data); Inside a procedure/function with an unsigned parameter, if an unsigned parameter is used in an expression or a value must be assigned to it, always use type casting. var x: word; procedure test(var a); begin writeln(PWord(@a)^); // = 95 PWord(@a)^ := 11; end; begin x:=95; test(x); // = 11 end.","title":"Untyped"},{"location":"units/","text":"PROGRAM The program header is not required, it is provided only for backward compatibility with Turbo Pascal . program name [(parameters, ...)] [: address]; It is possible to specify the compilation address after the colon character : , this is equivalent to the command-line switch -code address . program test; uses // List of unit dependencies goes here... // Implementation of procedures, and functions goes here... end. UNIT The UNIT modules come only in the form of source .pas files, they cannot be compiled separately. The UNIT modules consist of sections: INTERFACE wymagana IMPLEMENTATION wymagana INITIALIZATION opcjonalna . { Example UNIT } unit Unit1; interface uses // List of unit dependencies goes here... // Interface section goes here implementation uses // List of unit dependencies goes here... // Implementation of procedures, and functions goes here... initialization // Unit initialization code goes here... end. Example: unit test; interface type TUInt24 = record byte0: byte; byte1: byte; byte2: byte; end; const LoRes = 1; MedRes = 2; HiRes = 3; procedure Print(a: string); implementation uses test2; procedure Print(a: string); begin writeln(a); end; end. LIBRARY The library header is required. library name [: address]; It is possible to specify the compilation address after the colon character : , this is equivalent to the command-line switch -code address . The structure of the library is similar to the unit module, program program. { Example LIBRARY } library lib1; uses // List of unit dependencies goes here... // Implementation of procedures, and functions goes here... // exported subroutine(s), variable(s) exports idents, ... ; // optional library initialization code goes here... begin end. By default, functions and procedures declared and implemented in the library are not available to a programmer who wants to use the library. To make functions or procedures from the library available, they must be exported in the exports clause. Functions, procedures and other identifiers are exported with the exact names specified in the exports clause. To use libraries in UNIT modules or PROGRAM program, they must first be compiled and assembled, the Mad Assembler-a -hm switch must be active. mads.exe library.pas -hm -xi:<Mad_Pascal_path>\\base We cannot place .pas files with library source code in the uses clause. To use the identifiers exported in LIBRARY we use the EXTERNAL modifier. USES The uses clause imports identifiers from unit modules. Each Mad-Pascal unit - program , unit , or library - can have a maximum of one uses clause per section, which must appear immediately after the section headers. Section headers are interface , implementation in unit modules. There are no explicit section headers in program and library , so the uses clause appears immediately after the program , library header. uses crt, sysutils, atari; The SYSTEM module cannot be in this list, because it is always loaded by the compiler by default. The order in which modules appear is important because it determines the order in which they are initialized. Modules are initialized in the same order in which they appear in the uses clause. Identifiers are searched for in reverse order, that is, when the compiler looks for an identifier, it looks for it first in the last module in the uses clause, then in the penultimate one, and so on. This is important when two or more modules in the uses clause declare the same identifier. uses graph, vbxe; In both GRAPH and VBXE modules there is a SetColor and Line procedure, for the aforementioned example references to these procedures will be made by the VBXE module, uses vbxe, graph; references to these procedures will be made by the GRAPH module. We can also directly refer to the identifier from a specific module, such as: vbxe.Line graph.Line vbxe.SetColor graph.SetColor The compiler will look for source versions of all modules listed in the uses clause based on the path from which the mp.exe compiler was run. Using the IN keyword, we can override the automatic module search mechanism. uses unita in '..\\unita.pas'; The unita module is searched for in the parent directory of the current compiler working directory. You can add a {$UNITPATH ..} directive to ensure that the module is found no matter where the current compiler working directory is. When the compiler looks for module files, it adds the .pas extension to the module name. $LIBRARYPATH {$LIBRARYPATH path1; path2; ...} The $LIBRARYPATH directive allows you to indicate additional search paths for UNIT modules declared by uses . $UNITPATH {$UNITPATH path1; path2; ...} The $UNITPATH directive allows you to indicate additional search paths for UNIT modules declared by uses .","title":"Programs, units, librarys"},{"location":"units/#_1","text":"","title":""},{"location":"units/#program","text":"The program header is not required, it is provided only for backward compatibility with Turbo Pascal . program name [(parameters, ...)] [: address]; It is possible to specify the compilation address after the colon character : , this is equivalent to the command-line switch -code address . program test; uses // List of unit dependencies goes here... // Implementation of procedures, and functions goes here... end.","title":"PROGRAM"},{"location":"units/#unit","text":"The UNIT modules come only in the form of source .pas files, they cannot be compiled separately. The UNIT modules consist of sections: INTERFACE wymagana IMPLEMENTATION wymagana INITIALIZATION opcjonalna . { Example UNIT } unit Unit1; interface uses // List of unit dependencies goes here... // Interface section goes here implementation uses // List of unit dependencies goes here... // Implementation of procedures, and functions goes here... initialization // Unit initialization code goes here... end. Example: unit test; interface type TUInt24 = record byte0: byte; byte1: byte; byte2: byte; end; const LoRes = 1; MedRes = 2; HiRes = 3; procedure Print(a: string); implementation uses test2; procedure Print(a: string); begin writeln(a); end; end.","title":"UNIT"},{"location":"units/#library","text":"The library header is required. library name [: address]; It is possible to specify the compilation address after the colon character : , this is equivalent to the command-line switch -code address . The structure of the library is similar to the unit module, program program. { Example LIBRARY } library lib1; uses // List of unit dependencies goes here... // Implementation of procedures, and functions goes here... // exported subroutine(s), variable(s) exports idents, ... ; // optional library initialization code goes here... begin end. By default, functions and procedures declared and implemented in the library are not available to a programmer who wants to use the library. To make functions or procedures from the library available, they must be exported in the exports clause. Functions, procedures and other identifiers are exported with the exact names specified in the exports clause. To use libraries in UNIT modules or PROGRAM program, they must first be compiled and assembled, the Mad Assembler-a -hm switch must be active. mads.exe library.pas -hm -xi:<Mad_Pascal_path>\\base We cannot place .pas files with library source code in the uses clause. To use the identifiers exported in LIBRARY we use the EXTERNAL modifier.","title":"LIBRARY"},{"location":"units/#uses","text":"The uses clause imports identifiers from unit modules. Each Mad-Pascal unit - program , unit , or library - can have a maximum of one uses clause per section, which must appear immediately after the section headers. Section headers are interface , implementation in unit modules. There are no explicit section headers in program and library , so the uses clause appears immediately after the program , library header. uses crt, sysutils, atari; The SYSTEM module cannot be in this list, because it is always loaded by the compiler by default. The order in which modules appear is important because it determines the order in which they are initialized. Modules are initialized in the same order in which they appear in the uses clause. Identifiers are searched for in reverse order, that is, when the compiler looks for an identifier, it looks for it first in the last module in the uses clause, then in the penultimate one, and so on. This is important when two or more modules in the uses clause declare the same identifier. uses graph, vbxe; In both GRAPH and VBXE modules there is a SetColor and Line procedure, for the aforementioned example references to these procedures will be made by the VBXE module, uses vbxe, graph; references to these procedures will be made by the GRAPH module. We can also directly refer to the identifier from a specific module, such as: vbxe.Line graph.Line vbxe.SetColor graph.SetColor The compiler will look for source versions of all modules listed in the uses clause based on the path from which the mp.exe compiler was run. Using the IN keyword, we can override the automatic module search mechanism. uses unita in '..\\unita.pas'; The unita module is searched for in the parent directory of the current compiler working directory. You can add a {$UNITPATH ..} directive to ensure that the module is found no matter where the current compiler working directory is. When the compiler looks for module files, it adds the .pas extension to the module name.","title":"USES"},{"location":"units/#librarypath","text":"{$LIBRARYPATH path1; path2; ...} The $LIBRARYPATH directive allows you to indicate additional search paths for UNIT modules declared by uses .","title":"$LIBRARYPATH"},{"location":"units/#unitpath","text":"{$UNITPATH path1; path2; ...} The $UNITPATH directive allows you to indicate additional search paths for UNIT modules declared by uses .","title":"$UNITPATH"},{"location":"usage/","text":"Compiler Options Syntax: mp <inputfile>.pas [options] -ipath:<folder> Add the folder <folder> to the unit include path -define:<symbol> Define the symbol <symbol> -cpu:<cpu> Specify the CPU mode: 6502 (default), 65c02, 65816 -target:<platform> Specify the target platform: a8 (default), c4p, c64, neo, raw, x16 -code:<address> Specify the memory start address for the code -data:<address> Specify the memory start address for variables and arrays -stack:<address> Specify the memory start address for the software stack (64 bytes required) -zpage:<address> Specify the memory start address of variables in the zero page (26 bytes required) -o:<outputfile> Specify the output file path (default <inputfile>.a65) -diag Activate diagnostics mode The unit include path must contain the Mad-Pascal folder lib which contains the standard Pascal libraries. Additional optional standard libraries are in the blib , dlib and wlib folders. mp.exe example.pas -ipath:<MadPascalPath>\\lib -ipath:<MadPascalPath>\\blib The -target option supports the following values for the target platform: * a8 - Atari 8-bit computers . This is the default if the option is not specified. * c4p - Commodore Plus/4 computers * c64 - Commodore C64 computers * neo - Neo6502 computers * raw - Raw binary output without header. * x16 - Commander X16 computers The -diag option activates the generation of an additional *.txt file with information about all used variables, procedures, and functions. The default output file name is <inputfile>.a65 . It must be assembled using Mad-Assembler . The assembler include path must contain the Mad-Pascal assembler base folder using, for example: mads example.a65 -x -i:<MadPascalPath>\\base Using the -x option to Exclude unreferenced procedures is mandatory. It ensures that only the used parts of the libraries are compiled and the resulting MOS 6502 object code has the minimum size. Exit Codes 0 = No errors occurred, the output files were created correctly 2 = Errors occurred, and compiling was aborted 3 = Wrong parameters were specified, and compiling was not started Warning messages issued by Mad-Pascal do not affect the exit code.","title":"Usage"},{"location":"usage/#compiler-options","text":"Syntax: mp <inputfile>.pas [options] -ipath:<folder> Add the folder <folder> to the unit include path -define:<symbol> Define the symbol <symbol> -cpu:<cpu> Specify the CPU mode: 6502 (default), 65c02, 65816 -target:<platform> Specify the target platform: a8 (default), c4p, c64, neo, raw, x16 -code:<address> Specify the memory start address for the code -data:<address> Specify the memory start address for variables and arrays -stack:<address> Specify the memory start address for the software stack (64 bytes required) -zpage:<address> Specify the memory start address of variables in the zero page (26 bytes required) -o:<outputfile> Specify the output file path (default <inputfile>.a65) -diag Activate diagnostics mode The unit include path must contain the Mad-Pascal folder lib which contains the standard Pascal libraries. Additional optional standard libraries are in the blib , dlib and wlib folders. mp.exe example.pas -ipath:<MadPascalPath>\\lib -ipath:<MadPascalPath>\\blib The -target option supports the following values for the target platform: * a8 - Atari 8-bit computers . This is the default if the option is not specified. * c4p - Commodore Plus/4 computers * c64 - Commodore C64 computers * neo - Neo6502 computers * raw - Raw binary output without header. * x16 - Commander X16 computers The -diag option activates the generation of an additional *.txt file with information about all used variables, procedures, and functions. The default output file name is <inputfile>.a65 . It must be assembled using Mad-Assembler . The assembler include path must contain the Mad-Pascal assembler base folder using, for example: mads example.a65 -x -i:<MadPascalPath>\\base Using the -x option to Exclude unreferenced procedures is mandatory. It ensures that only the used parts of the libraries are compiled and the resulting MOS 6502 object code has the minimum size.","title":"Compiler Options"},{"location":"usage/#exit-codes","text":"0 = No errors occurred, the output files were created correctly 2 = Errors occurred, and compiling was aborted 3 = Wrong parameters were specified, and compiling was not started Warning messages issued by Mad-Pascal do not affect the exit code.","title":"Exit Codes"},{"location":"variables/","text":"VAR The word VAR begins the variable declaration section. var label: type; label: type = value; var a: word; b: byte = 1; c: Boolean = true; s: string = 'Atari'; tb: array [0..3] of byte = (0,1,2,3); VOLATILE The VOLATILE modifier marks a variable as so-called volatile. Marking it as VOLATILE disables optimization of the resulting code for that variable. Every read access to the variable will read from the memory location and will not re-use values that were already read by previous instructions. This is useful for hardware registers whose values may change with each successive read and for variables that are modified in parallel by other code the is not known to the compiler, for example by interrupt handlers. var [volatile] joy : byte absolute $ff08; pio : byte absolute $fd30; begin repeat pio := $ff; joy := 2; if (joy xor $ff) = 1 then writeln('UP'); until false; end. ABSOLUTE The ABSOLUTE modifier allows you to set the address in memory for VAR variables. var a: byte absolute $0600; tb: array [0..255] of byte absolute $a000; tab: array [0..3] of byte; v: integer absolute tab; procedure test(var buf); var ptr: PByte absolute buf; REGISTER The REGISTER modifier sets the memory address for VAR variables on the zero page (a maximum of 16 bytes can be allocated). var a: byte register; c: integer register; WARNING: The same 16-byte area of the zero page is used by the compiler allocating its EDX ECX EAX registers there, so using the REGISTER modifier is not possible when a procedure or function also uses REGISTER . procedure test(a,b,c: integer); register; Initialization Mad Pascal initializes all global and local variables once upon program start to the equivalent of zero or the explicitly specifed values. Note that this is different from the FPC behavior where only global variables are guranteed to be initialized. Because initialization only takes place upon program start and because it is not guranteed in FPC you should always explicitly assign values to local variables when a procedure or functions is entered. The syntax for specifying the initialization values in CONST and VAR declarations is identical. After the word specifying the data type, place the = character and the initial value. Array initialization After the word specifying the data type of the array, place the = character and the subsequent elements of the array between the round brackets ( val0, val1, ... ) : const pbox : array [0..1] of word = (12,10); var pbox : array [0..1] of word = (12,10); In the case of a two-dimensional array: pbox : array [0..1, 0..1] of word = ( (12,10) , (1,6) ); We can instantiate an array of type CHAR by STRING : pbox : array [0..4] of char = 'Hello'; It is possible to initialize an array without specifying its size using square brackets [ ] : pbox : array of char = ['H', 'e', 'l', 'l', 'o']; pbox : array of word = [1,2,3,4,5]; pbox : array of char = 'Hello'; // char arry without square brackets [ ] It is possible to initialize an array of type BYTE from a binary file, using the directive {$bin2csv filename} : tb: array of byte = [ {$bin2csv filename} ]; tb: array [0..11] of byte = ( 1,2,3, {$bin2csv filename} );","title":"Variables"},{"location":"variables/#_1","text":"","title":""},{"location":"variables/#var","text":"The word VAR begins the variable declaration section. var label: type; label: type = value; var a: word; b: byte = 1; c: Boolean = true; s: string = 'Atari'; tb: array [0..3] of byte = (0,1,2,3);","title":"VAR"},{"location":"variables/#volatile","text":"The VOLATILE modifier marks a variable as so-called volatile. Marking it as VOLATILE disables optimization of the resulting code for that variable. Every read access to the variable will read from the memory location and will not re-use values that were already read by previous instructions. This is useful for hardware registers whose values may change with each successive read and for variables that are modified in parallel by other code the is not known to the compiler, for example by interrupt handlers. var [volatile] joy : byte absolute $ff08; pio : byte absolute $fd30; begin repeat pio := $ff; joy := 2; if (joy xor $ff) = 1 then writeln('UP'); until false; end.","title":"VOLATILE"},{"location":"variables/#absolute","text":"The ABSOLUTE modifier allows you to set the address in memory for VAR variables. var a: byte absolute $0600; tb: array [0..255] of byte absolute $a000; tab: array [0..3] of byte; v: integer absolute tab; procedure test(var buf); var ptr: PByte absolute buf;","title":"ABSOLUTE"},{"location":"variables/#register","text":"The REGISTER modifier sets the memory address for VAR variables on the zero page (a maximum of 16 bytes can be allocated). var a: byte register; c: integer register; WARNING: The same 16-byte area of the zero page is used by the compiler allocating its EDX ECX EAX registers there, so using the REGISTER modifier is not possible when a procedure or function also uses REGISTER . procedure test(a,b,c: integer); register;","title":"REGISTER"},{"location":"variables/#initialization","text":"Mad Pascal initializes all global and local variables once upon program start to the equivalent of zero or the explicitly specifed values. Note that this is different from the FPC behavior where only global variables are guranteed to be initialized. Because initialization only takes place upon program start and because it is not guranteed in FPC you should always explicitly assign values to local variables when a procedure or functions is entered. The syntax for specifying the initialization values in CONST and VAR declarations is identical. After the word specifying the data type, place the = character and the initial value.","title":"Initialization"},{"location":"variables/#array-initialization","text":"After the word specifying the data type of the array, place the = character and the subsequent elements of the array between the round brackets ( val0, val1, ... ) : const pbox : array [0..1] of word = (12,10); var pbox : array [0..1] of word = (12,10); In the case of a two-dimensional array: pbox : array [0..1, 0..1] of word = ( (12,10) , (1,6) ); We can instantiate an array of type CHAR by STRING : pbox : array [0..4] of char = 'Hello'; It is possible to initialize an array without specifying its size using square brackets [ ] : pbox : array of char = ['H', 'e', 'l', 'l', 'o']; pbox : array of word = [1,2,3,4,5]; pbox : array of char = 'Hello'; // char arry without square brackets [ ] It is possible to initialize an array of type BYTE from a binary file, using the directive {$bin2csv filename} : tb: array of byte = [ {$bin2csv filename} ]; tb: array [0..11] of byte = ( 1,2,3, {$bin2csv filename} );","title":"Array initialization"}]}