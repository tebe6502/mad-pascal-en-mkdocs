<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="author" content="TeBe" />
      <link rel="shortcut icon" href="../img/favicon.ico" />
    <title>Types - Mad-Pascal</title>
    <link rel="stylesheet" href="../css/theme.css" />
    <link rel="stylesheet" href="../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "Types";
        var mkdocs_page_input_path = "types.md";
        var mkdocs_page_url = null;
      </script>
    
    <!--[if lt IE 9]>
      <script src="../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/delphi.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href=".." class="icon icon-home"> Mad-Pascal
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../introduction/">Introduction</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../map/">Memory map</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../usage/">Usage</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../syntax/">Syntax</a>
                </li>
              </ul>
              <ul class="current">
                <li class="toctree-l1 current"><a class="reference internal current" href="#">Types</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#ordinal-types">Ordinal types</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#boolean-types">Boolean types</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#enumeration-types">Enumeration types</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#real-types">Real types</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#char-types">Char types</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#pointers">Pointers</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#static-arrays">Static arrays</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#record-types">Record types</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#table-of-records">Table of records</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#object-types">Object types</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#procedural">Procedural</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#file-types">File types</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#untyped">Untyped</a>
    </li>
    </ul>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../constants/">Constants</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../variables/">Variables</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../instructions/">Instructions</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../units/">Programs, units, librarys</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../procedures-functions/">Procedures, functions, modifiers</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../macros/">Macros</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../asm/">Assembler inlining</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../resources/">Resource files</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../files/">File operations</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../interrupts/">Interrupt handling</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../ados/">Alternatives to DOS</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../essential-libraries/">Essential libraries</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../tips/">Tips and tricks</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../examples/">Examples</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../projects/">Projects</a>
                </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="..">Mad-Pascal</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href=".." class="icon icon-home" aria-label="Docs"></a></li>
      <li class="breadcrumb-item active">Types</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="_1"></h1>
<h2 id="ordinal-types"><a href="https://www.freepascal.org/docs-html/ref/refsu4.html#x26-250003.1.1">Ordinal types</a></h2>
<table>
<thead>
<tr>
<th style="text-align: left;">Type</th>
<th style="text-align: center;">Range</th>
<th style="text-align: center;">Size in bytes</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">BYTE</td>
<td style="text-align: center;">0 .. 255</td>
<td style="text-align: center;">1</td>
</tr>
<tr>
<td style="text-align: left;">SHORTINT</td>
<td style="text-align: center;">-128 .. 127</td>
<td style="text-align: center;">1</td>
</tr>
<tr>
<td style="text-align: left;">WORD</td>
<td style="text-align: center;">0 .. 65535</td>
<td style="text-align: center;">2</td>
</tr>
<tr>
<td style="text-align: left;">SMALLINT</td>
<td style="text-align: center;">-32768 .. 32767</td>
<td style="text-align: center;">2</td>
</tr>
<tr>
<td style="text-align: left;">CARDINAL</td>
<td style="text-align: center;">0 .. 4294967295</td>
<td style="text-align: center;">4</td>
</tr>
<tr>
<td style="text-align: left;">LONGWORD</td>
<td style="text-align: center;">0 .. 4294967295</td>
<td style="text-align: center;">4</td>
</tr>
<tr>
<td style="text-align: left;">DWORD</td>
<td style="text-align: center;">0 .. 4294967295</td>
<td style="text-align: center;">4</td>
</tr>
<tr>
<td style="text-align: left;">UINT32</td>
<td style="text-align: center;">0 .. 4294967295</td>
<td style="text-align: center;">4</td>
</tr>
<tr>
<td style="text-align: left;">INTEGER</td>
<td style="text-align: center;">-2147483648 .. 2147483647</td>
<td style="text-align: center;">4</td>
</tr>
<tr>
<td style="text-align: left;">LONGINT</td>
<td style="text-align: center;">-2147483648 .. 2147483647</td>
<td style="text-align: center;">4</td>
</tr>
</tbody>
</table>
<p><br/></p>
<h2 id="boolean-types"><a href="https://www.freepascal.org/docs-html/ref/refsu4.html#x26-250003.1.1">Boolean types</a></h2>
<table>
<thead>
<tr>
<th style="text-align: left;">Type</th>
<th style="text-align: center;">Ord(True)</th>
<th style="text-align: center;">Size in bytes</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">BOOLEAN</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
</tr>
</tbody>
</table>
<p><br/></p>
<h2 id="enumeration-types"><a href="https://www.freepascal.org/docs-html/ref/refsu4.html#x26-280003.1.1">Enumeration types</a></h2>
<p>The enumeration type in <strong>Mad-Pascal</strong> has been implemented in its basic form, i.e.:</p>
<pre><code class="language-delphi">Type
  Days = (monday,tuesday,wednesday,thursday,friday,
          saturday,sunday);

  Joy = (right_down = 5, right_up, right, left_down = 9, left_up, left, down = 13, up, none);
</code></pre>
<p>The enumeration type is stored only in the memory of the <strong>Mad-Pascal</strong> compiler, no information about the enumeration type fields will be stored in the result file. It is permissible to use the <code>ORD</code>, <code>SIZEOF</code> and casts on the enumeration type.</p>
<pre><code class="language-delphi">var
   d: Days;

   d:=friday;
   writeln(ord(d));
   writeln(ord(sunday));
   writeln(sizeof(days));
   writeln(sizeof(monday));

   d:=days(20);

   case d of
    sunday: writeln('sunday');
   end;
</code></pre>
<p>Currently, the <strong>Mad-Pascal</strong> compiler does not check the correctness of enumeration types for <code>IF ELSE</code> operations.</p>
<h2 id="real-types"><a href="https://www.freepascal.org/docs-html/ref/refsu5.html#x27-300003.1.2">Real types</a></h2>
<table>
<thead>
<tr>
<th style="text-align: left;">Type</th>
<th style="text-align: center;">Range</th>
<th style="text-align: center;">Size in bytes</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">SHORTREAL (Q8.8)</td>
<td style="text-align: center;">-128..127</td>
<td style="text-align: center;">2</td>
</tr>
<tr>
<td style="text-align: left;">REAL (Q24.8)</td>
<td style="text-align: center;">-8388608..8388607</td>
<td style="text-align: center;">4</td>
</tr>
<tr>
<td style="text-align: left;">SINGLE (IEEE-754)</td>
<td style="text-align: center;">1.5E-45 .. 3.4E38</td>
<td style="text-align: center;">4</td>
</tr>
<tr>
<td style="text-align: left;">FLOAT (IEEE-754)</td>
<td style="text-align: center;">1.5E-45 .. 3.4E38</td>
<td style="text-align: center;">4</td>
</tr>
<tr>
<td style="text-align: left;">FLOAT16 (IEEE-754)</td>
<td style="text-align: center;">65504 .. -65504</td>
<td style="text-align: center;">2</td>
</tr>
</tbody>
</table>
<p><br/>
Conversion of <code>FLOAT</code> <code>SINGLE</code> to <code>INTEGER</code> type is only available in the range <code>INTEGER</code>. The <code>INTEGER</code> type will not allow to present the maximum value <code>3.4E38</code> of  <code>FLOAT</code> <code>SINGLE</code> type.</p>
<h2 id="char-types"><a href="https://www.freepascal.org/docs-html/ref/refsu6.html#x29-320003.2.1">Char types</a></h2>
<table>
<thead>
<tr>
<th style="text-align: left;">Type</th>
<th style="text-align: center;">Range</th>
<th style="text-align: center;">Size in bytes</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">CHAR</td>
<td style="text-align: center;">ATASCII (0 .. 255)</td>
<td style="text-align: center;">1</td>
</tr>
<tr>
<td style="text-align: left;">STRING</td>
<td style="text-align: center;">1 .. 255</td>
<td style="text-align: center;">256</td>
</tr>
<tr>
<td style="text-align: left;">PCHAR</td>
<td style="text-align: center;">0 .. 65535</td>
<td style="text-align: center;">2</td>
</tr>
</tbody>
</table>
<p><br/>
The <code>STRING</code> is represented as an array with a possible maximum size <code>[0..255]</code>. The first byte of such an array <code>[0]</code> is the string length from the range <code>0..255</code>. The actual character string begins from the byte <code>[1..]</code>.</p>
<p>A pointer to the <code>CHAR</code> type represents the <code>PCHAR</code> string. The terminator of the <code>PCHAR</code> string is the <code>#0</code> character.</p>
<p>It is allowed to use additional characters after the final apostrophe, such as <code>*</code>, <code>~</code>.</p>
<p>The character <code>*</code> means a string in the inverse; the tilde <code>~</code> means a string in <strong>ANTIC</strong> codes.</p>
<p>Another way to modify the output characters is to use the system variable <code>TextAttr</code>, each character output to the screen is increased by the value <code>TextAttr</code> (default = 0).</p>
<pre><code class="language-delphi">a: string = 'Atari'*;         // a character string in the inverse
b: string = 'Spectrum'~;      // a character string in ANTIC codes
c: char = 'X'~*;              // a character in inverted ANTIC codes
</code></pre>
<h2 id="pointers"><a href="https://www.freepascal.org/docs-html/ref/refse15.html">Pointers</a></h2>
<table>
<thead>
<tr>
<th style="text-align: left;">Type</th>
<th style="text-align: center;">Range</th>
<th style="text-align: center;">Size in bytes</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">POINTER</td>
<td style="text-align: center;">0 .. 65535</td>
<td style="text-align: center;">2</td>
</tr>
</tbody>
</table>
<p><br/>
Indicators in <strong>Mad-Pascal</strong> can be typed and without a specific type, e.g.:</p>
<pre><code class="language-delphi">a: ^word;         // a typed pointer to a word
b: pointer;       // an untyped pointer
</code></pre>
<p>An uninitialized pointer will most often have the address of <code>$0000</code>, you should make sure that before you use it, you will have initialized it with the address of the appropriate variable, e.g.:</p>
<pre><code class="language-delphi">a := @tmp;         // pointer A is assigned the address of the TMP variable
</code></pre>
<p>If you don't do this, if you run such a program on a <strong>PC</strong>, you may cause a memory protection fault <strong>Access Violation</strong>.</p>
<p>Increasing the pointer using <code>INC</code> increases it by the size of the type it indicates. Decreasing the pointer using <code>DEC</code> reduces it by the size of the type it indicates. If the type is unspecified, the default step for increase/decrease is <code>1</code>.</p>
<p>For pointers, relation operations <code>=</code>, <code>&lt;&gt;</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>, and arithmetic operations <code>+</code> and <code>-</code> are allowed.</p>
<p>Using a pointer, we can cast a variable to another type:</p>
<pre><code class="language-delphi">var
   s: single;
   d: cardinal;

begin

 s := 3.14;

 d:=PCardinal(@s)^; // d = $4048F5C3

end;
</code></pre>
<h2 id="static-arrays"><a href="https://www.freepascal.org/docs-html/ref/refsu14.html#x38-500003.3.1">Static arrays</a></h2>
<p>Tables in <strong>Mad-Pascal</strong> are only static, one-dimensional or two-dimensional with an initial index equal to <code>0</code>, e.g:</p>
<pre><code class="language-delphi">var tb: array [0..100] of word;
var tb2: array [0..15, 0..31] of Boolean;
</code></pre>
<p>For an initial index other than zero, an error <strong>Error Array lower bound is not zero</strong> is generated.</p>
<p>In the memory the array is represented by the pointer <code>POINTER</code>, the pointer is the address of the array in memory (WORD). The quickest way to refer to the table from an <code>ASM</code> block is to use the prefix <code>ADR</code>, e.g.:</p>
<pre><code>asm
{ lda adr.tb,y   ; direct reference to the TB array
  lda tb         ; reference to the TB array pointer
};
</code></pre>
<p>The compiler generates code for the arrays depending on their declaration:</p>
<ul>
<li>when the number of bytes does not exceed 256 bytes</li>
</ul>
<pre><code class="language-delphi">array [0..255] of byte
array [0..127] of word
array [0..63] of cardinal
</code></pre>
<p>When the number of bytes occupied by the array does not exceed 256 bytes, the fastest code referring directly to the address of the array (prefix <code>ADR.</code>) is generated without the pointer. It is not possible to change the address for such an array.</p>
<pre><code>ldy #118
lda adr.tb,y
</code></pre>
<ul>
<li>when the number of elements of an array is <code>1</code></li>
</ul>
<pre><code class="language-delphi">array [0..0] of type
</code></pre>
<p>When the number of elements of an array is <code>1</code> it is treated specifically. The code generated refers to the array through the pointer. It is possible to set a new address for such a table.</p>
<pre><code>lda TB
add I
tay
lda TB+1
adc #$00
sta bp+1
lda (bp),y
</code></pre>
<ul>
<li>when the number of bytes exceeds 256 bytes</li>
</ul>
<pre><code class="language-delphi">array [0..255+1] of byte
array [0..127+1] of word
array [0..63+1] of cardinal
</code></pre>
<p>When the number of bytes occupied by the array exceeds 256 bytes, the generated code refers to the array via an pointer. When the number of bytes occupied by the array exceeds 256 bytes, the generated code refers to the array through a pointer.</p>
<pre><code>lda TB
add I
tay
lda TB+1
adc #$00
sta bp+1
lda (bp),y
</code></pre>
<h2 id="record-types"><a href="https://www.freepascal.org/docs-html/ref/refsu15.html#x39-550003.3.2">Record types</a></h2>
<p>In the memory the record is represented by a pointer <code>POINTER</code>.</p>
<pre><code>type
    TPoint = record x,y: byte end;
var px: TPoint;
</code></pre>
<p>By default, records in <strong>Mad-Pascal</strong> are of type <code>PACKED</code>. The total size of the record fields is limited to 256 bytes.</p>
<p>If you want to maintain <strong>FPC</strong> compatibility, you should additionally precede the word <code>record</code> with the word <code>packed</code>.</p>
<p>Without this, the size of the memory that the record takes varies, it occupies less memory on <strong>MOS 6502</strong> target, potentially several bytes more on <strong>Windows</strong>.</p>
<pre><code class="language-delphi">type
    TPoint = packed record x,y: byte end;

    var px: TPoint;
</code></pre>
<p>Access to record fields from the assembly:</p>
<pre><code>mwa px bp2
ldy #px.x-DATAORIGIN
lda (bp2),y
</code></pre>
<h3 id="table-of-records">Table of records</h3>
<p><strong>Mad-Pascal</strong> only supports arrays of record pointers.</p>
<pre><code class="language-Delphi">    type
        TPoint = record x,y: byte end;    

    var 
        tab: array [0..3] of ^TPoint;
</code></pre>
<p>Such an array must be instantiated with the corresponding record addresses, by default all fields of such an array are zeroed at the beginning.</p>
<p>The first way to instantiate an array of record indicators:</p>
<pre><code class="language-Delphi">    var
       a1,a2,a3,a4: TPoint;       

    begin
     tab[0] := @a1;
     tab[1] := @a2;
     tab[2] := @a3;
     tab[3] := @a4;   
    end.
</code></pre>
<p>Second way:</p>
<pre><code class="language-Delphi">    begin
     GetMem(tab[0], sizeof(TPoint));
     GetMem(tab[1], sizeof(TPoint));
     GetMem(tab[2], sizeof(TPoint));
     GetMem(tab[3], sizeof(TPoint));
    end.
</code></pre>
<p>Access record fields from such an array:</p>
<pre><code class="language-Delphi">  writeln(tab[1].x);
  writeln(tab[1].y);
</code></pre>
<h2 id="object-types"><a href="https://www.freepascal.org/docs-html/ref/refse28.html#x60-780005.1">Object types</a></h2>
<p>Objects are records with additional methods. In the memory, the object is represented by a pointer <code>POINTER</code>.</p>
<pre><code class="language-delphi">type
    TRMT = Object

    player: pointer;
    modul: pointer;

    procedure Init(a: byte); assembler;
    procedure Play; assembler;
    procedure Stop; assembler;

    end;
</code></pre>
<p>It is possible to use the <code>CONSTRUCTOR</code> and <code>DESTRUCTOR</code> procedures in objects. Such procedures can only be called manually.  </p>
<h2 id="procedural"><a href="https://www.freepascal.org/docs-html/ref/refse17.html">Procedural</a></h2>
<p>In memory, procedural type variables are represented by the <code>POINTER</code> type.</p>
<pre><code class="language-delphi">type
    tprc = procedure (a: byte; c: word);
    tfun = function (a:smallint; x: single): byte;

var
    fn: function (a,b,c: byte): word;
</code></pre>
<p>For the procedural type, procedures/functions with arguments require the <code>STDCALL</code> modifier, which will force the use of the program stack.</p>
<pre><code class="language-delphi">var
   fn: function (a,b: word): word;

function test(a,b,c,d: word): word; stdcall;
begin

end;

begin

fn := @test;

fn(1,2);

end;
</code></pre>
<p>For procedures with arguments instead of the <code>STDCALL</code> modifier, the <code>REGISTER</code> modifier is allowed, provided there are up to three arguments.</p>
<pre><code class="language-delphi">var
   prc: procedure (a,b: word);

procedure test(a,b,c: cardinal); register;
begin

// a -&gt; EDX
// b -&gt; ECX
// c -&gt; EAX

end;

begin

prc := @test;

prc(3,6);

end;
</code></pre>
<p>When no arguments are passed to the procedure/function, the use of modifier is not necessary.</p>
<h2 id="file-types"><a href="https://www.freepascal.org/docs-html/ref/refsu17.html#x41-590003.3.4">File types</a></h2>
<p>The <code>FILE</code> type represents the file handle and defines the record size.</p>
<pre><code class="language-delphi">type
  ftype = array [0..63] of cardinal;

var
  f: file;               // default record =128 bytes
  f: file of byte;       // 1 byte record
  f: file of ftype;      // 256 byte record (ftype = 64 * 4)
</code></pre>
<p>In the <strong>Atari 8-Bit</strong> memory, the FILE holder is represented by a pointer <code>POINTER</code> to an array of structure (size 12 bytes):</p>
<pre><code>.struct s@file
pfname   .word      ; pointer to string with filename
record   .word      ; record size
chanel   .byte      ; channel *$10
eof      .byte      ; EOF status
buffer   .word      ; load/write buffer
nrecord  .word      ; number of records for load/write
numread  .word      ; pointer to variable, length of loaded data
.ends
</code></pre>
<p>For procedures and functions, the <code>FILE</code>type can only be passed as a variable <code>VAR</code>.</p>
<h2 id="untyped"><a href="https://www.freepascal.org/docs-html/ref/refsu70.html">Untyped</a></h2>
<pre><code class="language-Delphi"> procedure Something (var Data);
 procedure Something (const Data);
</code></pre>
<p>Failure to specify the type of the parameter means that only the address of the parameter without the type designation will be passed to the procedure/function.</p>
<p>This is equivalent to the following C/C++ declaration:</p>
<pre><code class="language-Delphi"> void Something(void* Data);
</code></pre>
<p>Inside a procedure/function with an unsigned parameter, if an unsigned parameter is used in an expression or a value must be assigned to it, always use type casting.</p>
<pre><code>var x: word;

procedure test(var a);
begin

  writeln(PWord(@a)^);  // = 95

  PWord(@a)^ := 11;

end;

begin

  x:=95;

  test(x);              // = 11

end.
</code></pre>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../syntax/" class="btn btn-neutral float-left" title="Syntax"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../constants/" class="btn btn-neutral float-right" title="Constants">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
        <span>
          <a href="https://github.com/tebe6502/mad-pascal-en-mkdocs/" class="fa fa-github" style="color: #fcfcfc"> GitHub</a>
        </span>
    
    
      <span><a href="../syntax/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../constants/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script src="../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "..";</script>
    <script src="../js/theme_extra.js"></script>
    <script src="../js/theme.js"></script>
      <script src="../search/main.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
